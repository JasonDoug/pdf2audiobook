{"version":3,"sources":["turbopack:///[project]/Projects/Clones/pdf2audiobook/frontend/node_modules/next/src/build/webpack/loaders/next-flight-loader/server-reference.ts","turbopack:///[project]/Projects/Clones/pdf2audiobook/frontend/node_modules/next/src/server/lib/trace/constants.ts","turbopack:///[project]/Projects/Clones/pdf2audiobook/frontend/node_modules/next/src/shared/lib/is-thenable.ts","turbopack:///[project]/Projects/Clones/pdf2audiobook/frontend/node_modules/next/src/server/lib/trace/tracer.ts","turbopack:///[project]/Projects/Clones/pdf2audiobook/frontend/node_modules/next/src/lib/detached-promise.ts","turbopack:///[project]/Projects/Clones/pdf2audiobook/frontend/node_modules/next/src/lib/scheduler.ts","turbopack:///[project]/Projects/Clones/pdf2audiobook/frontend/node_modules/next/src/server/stream-utils/encoded-tags.ts","turbopack:///[project]/Projects/Clones/pdf2audiobook/frontend/node_modules/next/src/server/stream-utils/uint8array-helpers.ts","turbopack:///[project]/Projects/Clones/pdf2audiobook/frontend/node_modules/next/src/shared/lib/errors/constants.ts","turbopack:///[project]/Projects/Clones/pdf2audiobook/frontend/node_modules/next/src/shared/lib/segment-cache/output-export-prefetch-encoding.ts","turbopack:///[project]/Projects/Clones/pdf2audiobook/frontend/node_modules/next/src/client/components/app-router-headers.ts","turbopack:///[project]/Projects/Clones/pdf2audiobook/frontend/node_modules/next/src/shared/lib/hash.ts","turbopack:///[project]/Projects/Clones/pdf2audiobook/frontend/node_modules/next/src/shared/lib/router/utils/cache-busting-search-param.ts","turbopack:///[project]/Projects/Clones/pdf2audiobook/frontend/node_modules/next/src/server/stream-utils/node-web-streams-helper.ts","turbopack:///[project]/Projects/Clones/pdf2audiobook/frontend/node_modules/next/src/shared/lib/invariant-error.ts","turbopack:///[project]/Projects/Clones/pdf2audiobook/frontend/node_modules/next/src/shared/lib/page-path/ensure-leading-slash.ts","turbopack:///[project]/Projects/Clones/pdf2audiobook/frontend/node_modules/next/src/shared/lib/segment.ts","turbopack:///[project]/Projects/Clones/pdf2audiobook/frontend/node_modules/next/src/shared/lib/router/utils/app-paths.ts","turbopack:///[project]/Projects/Clones/pdf2audiobook/frontend/node_modules/next/src/server/app-render/encryption-utils.ts","turbopack:///[project]/Projects/Clones/pdf2audiobook/frontend/node_modules/next/src/client/components/hooks-server-context.ts","turbopack:///[project]/Projects/Clones/pdf2audiobook/frontend/node_modules/next/src/client/components/static-generation-bailout.ts","turbopack:///[project]/Projects/Clones/pdf2audiobook/frontend/node_modules/next/src/server/dynamic-rendering-utils.ts","turbopack:///[project]/Projects/Clones/pdf2audiobook/frontend/node_modules/next/src/lib/framework/boundary-constants.tsx","turbopack:///[project]/Projects/Clones/pdf2audiobook/frontend/node_modules/next/src/shared/lib/lazy-dynamic/bailout-to-csr.ts","turbopack:///[project]/Projects/Clones/pdf2audiobook/frontend/node_modules/next/src/shared/lib/promise-with-resolvers.ts","turbopack:///[project]/Projects/Clones/pdf2audiobook/frontend/node_modules/next/src/server/app-render/staged-rendering.ts","turbopack:///[project]/Projects/Clones/pdf2audiobook/frontend/node_modules/next/src/server/app-render/dynamic-rendering.ts","turbopack:///[project]/Projects/Clones/pdf2audiobook/frontend/node_modules/next/src/server/app-render/encryption.ts","turbopack:///[project]/Projects/Clones/pdf2audiobook/frontend/node_modules/next/src/server/web/spec-extension/cookies.ts","turbopack:///[project]/Projects/Clones/pdf2audiobook/frontend/node_modules/next/src/server/web/spec-extension/adapters/reflect.ts","turbopack:///[project]/Projects/Clones/pdf2audiobook/frontend/node_modules/next/src/server/web/spec-extension/adapters/request-cookies.ts","turbopack:///[project]/Projects/Clones/pdf2audiobook/frontend/node_modules/next/src/server/create-deduped-by-callsite-server-error-logger.ts","turbopack:///[project]/Projects/Clones/pdf2audiobook/frontend/node_modules/next/src/server/request/utils.ts","turbopack:///[project]/Projects/Clones/pdf2audiobook/frontend/node_modules/next/src/server/request/cookies.ts","turbopack:///[project]/Projects/Clones/pdf2audiobook/frontend/node_modules/next/src/server/web/spec-extension/adapters/headers.ts","turbopack:///[project]/Projects/Clones/pdf2audiobook/frontend/node_modules/next/src/server/request/headers.ts","turbopack:///[project]/Projects/Clones/pdf2audiobook/frontend/node_modules/next/src/server/request/draft-mode.ts","turbopack:///[project]/Projects/Clones/pdf2audiobook/frontend/node_modules/next/headers.js","turbopack:///[project]/Projects/Clones/pdf2audiobook/frontend/node_modules/next/src/build/webpack/loaders/next-flight-loader/action-validate.ts"],"sourcesContent":["/* eslint-disable import/no-extraneous-dependencies */\nexport { registerServerReference } from 'react-server-dom-webpack/server'\n","/**\n * Contains predefined constants for the trace span name in next/server.\n *\n * Currently, next/server/tracer is internal implementation only for tracking\n * next.js's implementation only with known span names defined here.\n **/\n\n// eslint typescript has a bug with TS enums\n\nenum BaseServerSpan {\n  handleRequest = 'BaseServer.handleRequest',\n  run = 'BaseServer.run',\n  pipe = 'BaseServer.pipe',\n  getStaticHTML = 'BaseServer.getStaticHTML',\n  render = 'BaseServer.render',\n  renderToResponseWithComponents = 'BaseServer.renderToResponseWithComponents',\n  renderToResponse = 'BaseServer.renderToResponse',\n  renderToHTML = 'BaseServer.renderToHTML',\n  renderError = 'BaseServer.renderError',\n  renderErrorToResponse = 'BaseServer.renderErrorToResponse',\n  renderErrorToHTML = 'BaseServer.renderErrorToHTML',\n  render404 = 'BaseServer.render404',\n}\n\nenum LoadComponentsSpan {\n  loadDefaultErrorComponents = 'LoadComponents.loadDefaultErrorComponents',\n  loadComponents = 'LoadComponents.loadComponents',\n}\n\nenum NextServerSpan {\n  getRequestHandler = 'NextServer.getRequestHandler',\n  getRequestHandlerWithMetadata = 'NextServer.getRequestHandlerWithMetadata',\n  getServer = 'NextServer.getServer',\n  getServerRequestHandler = 'NextServer.getServerRequestHandler',\n  createServer = 'createServer.createServer',\n}\n\nenum NextNodeServerSpan {\n  compression = 'NextNodeServer.compression',\n  getBuildId = 'NextNodeServer.getBuildId',\n  createComponentTree = 'NextNodeServer.createComponentTree',\n  clientComponentLoading = 'NextNodeServer.clientComponentLoading',\n  getLayoutOrPageModule = 'NextNodeServer.getLayoutOrPageModule',\n  generateStaticRoutes = 'NextNodeServer.generateStaticRoutes',\n  generateFsStaticRoutes = 'NextNodeServer.generateFsStaticRoutes',\n  generatePublicRoutes = 'NextNodeServer.generatePublicRoutes',\n  generateImageRoutes = 'NextNodeServer.generateImageRoutes.route',\n  sendRenderResult = 'NextNodeServer.sendRenderResult',\n  proxyRequest = 'NextNodeServer.proxyRequest',\n  runApi = 'NextNodeServer.runApi',\n  render = 'NextNodeServer.render',\n  renderHTML = 'NextNodeServer.renderHTML',\n  imageOptimizer = 'NextNodeServer.imageOptimizer',\n  getPagePath = 'NextNodeServer.getPagePath',\n  getRoutesManifest = 'NextNodeServer.getRoutesManifest',\n  findPageComponents = 'NextNodeServer.findPageComponents',\n  getFontManifest = 'NextNodeServer.getFontManifest',\n  getServerComponentManifest = 'NextNodeServer.getServerComponentManifest',\n  getRequestHandler = 'NextNodeServer.getRequestHandler',\n  renderToHTML = 'NextNodeServer.renderToHTML',\n  renderError = 'NextNodeServer.renderError',\n  renderErrorToHTML = 'NextNodeServer.renderErrorToHTML',\n  render404 = 'NextNodeServer.render404',\n  startResponse = 'NextNodeServer.startResponse',\n\n  // nested inner span, does not require parent scope name\n  route = 'route',\n  onProxyReq = 'onProxyReq',\n  apiResolver = 'apiResolver',\n  internalFetch = 'internalFetch',\n}\n\nenum StartServerSpan {\n  startServer = 'startServer.startServer',\n}\n\nenum RenderSpan {\n  getServerSideProps = 'Render.getServerSideProps',\n  getStaticProps = 'Render.getStaticProps',\n  renderToString = 'Render.renderToString',\n  renderDocument = 'Render.renderDocument',\n  createBodyResult = 'Render.createBodyResult',\n}\n\nenum AppRenderSpan {\n  renderToString = 'AppRender.renderToString',\n  renderToReadableStream = 'AppRender.renderToReadableStream',\n  getBodyResult = 'AppRender.getBodyResult',\n  fetch = 'AppRender.fetch',\n}\n\nenum RouterSpan {\n  executeRoute = 'Router.executeRoute',\n}\n\nenum NodeSpan {\n  runHandler = 'Node.runHandler',\n}\n\nenum AppRouteRouteHandlersSpan {\n  runHandler = 'AppRouteRouteHandlers.runHandler',\n}\n\nenum ResolveMetadataSpan {\n  generateMetadata = 'ResolveMetadata.generateMetadata',\n  generateViewport = 'ResolveMetadata.generateViewport',\n}\n\nenum MiddlewareSpan {\n  execute = 'Middleware.execute',\n}\n\ntype SpanTypes =\n  | `${BaseServerSpan}`\n  | `${LoadComponentsSpan}`\n  | `${NextServerSpan}`\n  | `${StartServerSpan}`\n  | `${NextNodeServerSpan}`\n  | `${RenderSpan}`\n  | `${RouterSpan}`\n  | `${AppRenderSpan}`\n  | `${NodeSpan}`\n  | `${AppRouteRouteHandlersSpan}`\n  | `${ResolveMetadataSpan}`\n  | `${MiddlewareSpan}`\n\n// This list is used to filter out spans that are not relevant to the user\nexport const NextVanillaSpanAllowlist = [\n  MiddlewareSpan.execute,\n  BaseServerSpan.handleRequest,\n  RenderSpan.getServerSideProps,\n  RenderSpan.getStaticProps,\n  AppRenderSpan.fetch,\n  AppRenderSpan.getBodyResult,\n  RenderSpan.renderDocument,\n  NodeSpan.runHandler,\n  AppRouteRouteHandlersSpan.runHandler,\n  ResolveMetadataSpan.generateMetadata,\n  ResolveMetadataSpan.generateViewport,\n  NextNodeServerSpan.createComponentTree,\n  NextNodeServerSpan.findPageComponents,\n  NextNodeServerSpan.getLayoutOrPageModule,\n  NextNodeServerSpan.startResponse,\n  NextNodeServerSpan.clientComponentLoading,\n]\n\n// These Spans are allowed to be always logged\n// when the otel log prefix env is set\nexport const LogSpanAllowList = [\n  NextNodeServerSpan.findPageComponents,\n  NextNodeServerSpan.createComponentTree,\n  NextNodeServerSpan.clientComponentLoading,\n]\n\nexport {\n  BaseServerSpan,\n  LoadComponentsSpan,\n  NextServerSpan,\n  NextNodeServerSpan,\n  StartServerSpan,\n  RenderSpan,\n  RouterSpan,\n  AppRenderSpan,\n  NodeSpan,\n  AppRouteRouteHandlersSpan,\n  ResolveMetadataSpan,\n  MiddlewareSpan,\n}\n\nexport type { SpanTypes }\n","/**\n * Check to see if a value is Thenable.\n *\n * @param promise the maybe-thenable value\n * @returns true if the value is thenable\n */\nexport function isThenable<T = unknown>(\n  promise: Promise<T> | T\n): promise is Promise<T> {\n  return (\n    promise !== null &&\n    typeof promise === 'object' &&\n    'then' in promise &&\n    typeof promise.then === 'function'\n  )\n}\n","import type { FetchEventResult } from '../../web/types'\nimport type { TextMapSetter } from '@opentelemetry/api'\nimport type { SpanTypes } from './constants'\nimport { LogSpanAllowList, NextVanillaSpanAllowlist } from './constants'\n\nimport type {\n  ContextAPI,\n  Span,\n  SpanOptions,\n  Tracer,\n  AttributeValue,\n  TextMapGetter,\n} from 'next/dist/compiled/@opentelemetry/api'\nimport { isThenable } from '../../../shared/lib/is-thenable'\n\nlet api: typeof import('next/dist/compiled/@opentelemetry/api')\n\n// we want to allow users to use their own version of @opentelemetry/api if they\n// want to, so we try to require it first, and if it fails we fall back to the\n// version that is bundled with Next.js\n// this is because @opentelemetry/api has to be synced with the version of\n// @opentelemetry/tracing that is used, and we don't want to force users to use\n// the version that is bundled with Next.js.\n// the API is ~stable, so this should be fine\nif (process.env.NEXT_RUNTIME === 'edge') {\n  api = require('@opentelemetry/api') as typeof import('@opentelemetry/api')\n} else {\n  try {\n    api = require('@opentelemetry/api') as typeof import('@opentelemetry/api')\n  } catch (err) {\n    api =\n      require('next/dist/compiled/@opentelemetry/api') as typeof import('next/dist/compiled/@opentelemetry/api')\n  }\n}\n\nconst { context, propagation, trace, SpanStatusCode, SpanKind, ROOT_CONTEXT } =\n  api\n\nexport class BubbledError extends Error {\n  constructor(\n    public readonly bubble?: boolean,\n    public readonly result?: FetchEventResult\n  ) {\n    super()\n  }\n}\n\nexport function isBubbledError(error: unknown): error is BubbledError {\n  if (typeof error !== 'object' || error === null) return false\n  return error instanceof BubbledError\n}\n\nconst closeSpanWithError = (span: Span, error?: Error) => {\n  if (isBubbledError(error) && error.bubble) {\n    span.setAttribute('next.bubble', true)\n  } else {\n    if (error) {\n      span.recordException(error)\n      span.setAttribute('error.type', error.name)\n    }\n    span.setStatus({ code: SpanStatusCode.ERROR, message: error?.message })\n  }\n  span.end()\n}\n\ntype TracerSpanOptions = Omit<SpanOptions, 'attributes'> & {\n  parentSpan?: Span\n  spanName?: string\n  attributes?: Partial<Record<AttributeNames, AttributeValue | undefined>>\n  hideSpan?: boolean\n}\n\ninterface NextTracer {\n  getContext(): ContextAPI\n\n  /**\n   * Instruments a function by automatically creating a span activated on its\n   * scope.\n   *\n   * The span will automatically be finished when one of these conditions is\n   * met:\n   *\n   * * The function returns a promise, in which case the span will finish when\n   * the promise is resolved or rejected.\n   * * The function takes a callback as its second parameter, in which case the\n   * span will finish when that callback is called.\n   * * The function doesn't accept a callback and doesn't return a promise, in\n   * which case the span will finish at the end of the function execution.\n   *\n   */\n  trace<T>(\n    type: SpanTypes,\n    fn: (span?: Span, done?: (error?: Error) => any) => Promise<T>\n  ): Promise<T>\n  trace<T>(\n    type: SpanTypes,\n    fn: (span?: Span, done?: (error?: Error) => any) => T\n  ): T\n  trace<T>(\n    type: SpanTypes,\n    options: TracerSpanOptions,\n    fn: (span?: Span, done?: (error?: Error) => any) => Promise<T>\n  ): Promise<T>\n  trace<T>(\n    type: SpanTypes,\n    options: TracerSpanOptions,\n    fn: (span?: Span, done?: (error?: Error) => any) => T\n  ): T\n\n  /**\n   * Wrap a function to automatically create a span activated on its\n   * scope when it's called.\n   *\n   * The span will automatically be finished when one of these conditions is\n   * met:\n   *\n   * * The function returns a promise, in which case the span will finish when\n   * the promise is resolved or rejected.\n   * * The function takes a callback as its last parameter, in which case the\n   * span will finish when that callback is called.\n   * * The function doesn't accept a callback and doesn't return a promise, in\n   * which case the span will finish at the end of the function execution.\n   */\n  wrap<T = (...args: Array<any>) => any>(type: SpanTypes, fn: T): T\n  wrap<T = (...args: Array<any>) => any>(\n    type: SpanTypes,\n    options: TracerSpanOptions,\n    fn: T\n  ): T\n  wrap<T = (...args: Array<any>) => any>(\n    type: SpanTypes,\n    options: (...args: any[]) => TracerSpanOptions,\n    fn: T\n  ): T\n\n  /**\n   * Starts and returns a new Span representing a logical unit of work.\n   *\n   * This method do NOT modify the current Context by default. In result, any inner span will not\n   * automatically set its parent context to the span created by this method unless manually activate\n   * context via `tracer.getContext().with`. `trace`, or `wrap` is generally recommended as it gracefully\n   * handles context activation. (ref: https://github.com/open-telemetry/opentelemetry-js/issues/1923)\n   */\n  startSpan(type: SpanTypes): Span\n  startSpan(type: SpanTypes, options: TracerSpanOptions): Span\n\n  /**\n   * Returns currently activated span if current context is in the scope of the span.\n   * Returns undefined otherwise.\n   */\n  getActiveScopeSpan(): Span | undefined\n\n  /**\n   * Returns trace propagation data for the currently active context. The format is equal to data provided\n   * through the OpenTelemetry propagator API.\n   */\n  getTracePropagationData(): ClientTraceDataEntry[]\n}\n\ntype NextAttributeNames =\n  | 'next.route'\n  | 'next.page'\n  | 'next.rsc'\n  | 'next.segment'\n  | 'next.span_name'\n  | 'next.span_type'\n  | 'next.clientComponentLoadCount'\ntype OTELAttributeNames = `http.${string}` | `net.${string}`\ntype AttributeNames = NextAttributeNames | OTELAttributeNames\n\n/** we use this map to propagate attributes from nested spans to the top span */\nconst rootSpanAttributesStore = new Map<\n  number,\n  Map<AttributeNames, AttributeValue | undefined>\n>()\nconst rootSpanIdKey = api.createContextKey('next.rootSpanId')\nlet lastSpanId = 0\nconst getSpanId = () => lastSpanId++\n\nexport interface ClientTraceDataEntry {\n  key: string\n  value: string\n}\n\nconst clientTraceDataSetter: TextMapSetter<ClientTraceDataEntry[]> = {\n  set(carrier, key, value) {\n    carrier.push({\n      key,\n      value,\n    })\n  },\n}\n\nclass NextTracerImpl implements NextTracer {\n  /**\n   * Returns an instance to the trace with configured name.\n   * Since wrap / trace can be defined in any place prior to actual trace subscriber initialization,\n   * This should be lazily evaluated.\n   */\n  private getTracerInstance(): Tracer {\n    return trace.getTracer('next.js', '0.0.1')\n  }\n\n  public getContext(): ContextAPI {\n    return context\n  }\n\n  public getTracePropagationData(): ClientTraceDataEntry[] {\n    const activeContext = context.active()\n    const entries: ClientTraceDataEntry[] = []\n    propagation.inject(activeContext, entries, clientTraceDataSetter)\n    return entries\n  }\n\n  public getActiveScopeSpan(): Span | undefined {\n    return trace.getSpan(context?.active())\n  }\n\n  public withPropagatedContext<T, C>(\n    carrier: C,\n    fn: () => T,\n    getter?: TextMapGetter<C>\n  ): T {\n    const activeContext = context.active()\n    if (trace.getSpanContext(activeContext)) {\n      // Active span is already set, too late to propagate.\n      return fn()\n    }\n    const remoteContext = propagation.extract(activeContext, carrier, getter)\n    return context.with(remoteContext, fn)\n  }\n\n  // Trace, wrap implementation is inspired by datadog trace implementation\n  // (https://datadoghq.dev/dd-trace-js/interfaces/tracer.html#trace).\n  public trace<T>(\n    type: SpanTypes,\n    fn: (span?: Span, done?: (error?: Error) => any) => Promise<T>\n  ): Promise<T>\n  public trace<T>(\n    type: SpanTypes,\n    fn: (span?: Span, done?: (error?: Error) => any) => T\n  ): T\n  public trace<T>(\n    type: SpanTypes,\n    options: TracerSpanOptions,\n    fn: (span?: Span, done?: (error?: Error) => any) => Promise<T>\n  ): Promise<T>\n  public trace<T>(\n    type: SpanTypes,\n    options: TracerSpanOptions,\n    fn: (span?: Span, done?: (error?: Error) => any) => T\n  ): T\n  public trace<T>(...args: Array<any>) {\n    const [type, fnOrOptions, fnOrEmpty] = args\n\n    // coerce options form overload\n    const {\n      fn,\n      options,\n    }: {\n      fn: (span?: Span, done?: (error?: Error) => any) => T | Promise<T>\n      options: TracerSpanOptions\n    } =\n      typeof fnOrOptions === 'function'\n        ? {\n            fn: fnOrOptions,\n            options: {},\n          }\n        : {\n            fn: fnOrEmpty,\n            options: { ...fnOrOptions },\n          }\n\n    const spanName = options.spanName ?? type\n\n    if (\n      (!NextVanillaSpanAllowlist.includes(type) &&\n        process.env.NEXT_OTEL_VERBOSE !== '1') ||\n      options.hideSpan\n    ) {\n      return fn()\n    }\n\n    // Trying to get active scoped span to assign parent. If option specifies parent span manually, will try to use it.\n    let spanContext = this.getSpanContext(\n      options?.parentSpan ?? this.getActiveScopeSpan()\n    )\n    let isRootSpan = false\n\n    if (!spanContext) {\n      spanContext = context?.active() ?? ROOT_CONTEXT\n      isRootSpan = true\n    } else if (trace.getSpanContext(spanContext)?.isRemote) {\n      isRootSpan = true\n    }\n\n    const spanId = getSpanId()\n\n    options.attributes = {\n      'next.span_name': spanName,\n      'next.span_type': type,\n      ...options.attributes,\n    }\n\n    return context.with(spanContext.setValue(rootSpanIdKey, spanId), () =>\n      this.getTracerInstance().startActiveSpan(\n        spanName,\n        options,\n        (span: Span) => {\n          const startTime =\n            'performance' in globalThis && 'measure' in performance\n              ? globalThis.performance.now()\n              : undefined\n\n          const onCleanup = () => {\n            rootSpanAttributesStore.delete(spanId)\n            if (\n              startTime &&\n              process.env.NEXT_OTEL_PERFORMANCE_PREFIX &&\n              LogSpanAllowList.includes(type || ('' as any))\n            ) {\n              performance.measure(\n                `${process.env.NEXT_OTEL_PERFORMANCE_PREFIX}:next-${(\n                  type.split('.').pop() || ''\n                ).replace(\n                  /[A-Z]/g,\n                  (match: string) => '-' + match.toLowerCase()\n                )}`,\n                {\n                  start: startTime,\n                  end: performance.now(),\n                }\n              )\n            }\n          }\n\n          if (isRootSpan) {\n            rootSpanAttributesStore.set(\n              spanId,\n              new Map(\n                Object.entries(options.attributes ?? {}) as [\n                  AttributeNames,\n                  AttributeValue | undefined,\n                ][]\n              )\n            )\n          }\n          try {\n            if (fn.length > 1) {\n              return fn(span, (err) => closeSpanWithError(span, err))\n            }\n\n            const result = fn(span)\n            if (isThenable(result)) {\n              // If there's error make sure it throws\n              return result\n                .then((res) => {\n                  span.end()\n                  // Need to pass down the promise result,\n                  // it could be react stream response with error { error, stream }\n                  return res\n                })\n                .catch((err) => {\n                  closeSpanWithError(span, err)\n                  throw err\n                })\n                .finally(onCleanup)\n            } else {\n              span.end()\n              onCleanup()\n            }\n\n            return result\n          } catch (err: any) {\n            closeSpanWithError(span, err)\n            onCleanup()\n            throw err\n          }\n        }\n      )\n    )\n  }\n\n  public wrap<T = (...args: Array<any>) => any>(type: SpanTypes, fn: T): T\n  public wrap<T = (...args: Array<any>) => any>(\n    type: SpanTypes,\n    options: TracerSpanOptions,\n    fn: T\n  ): T\n  public wrap<T = (...args: Array<any>) => any>(\n    type: SpanTypes,\n    options: (...args: any[]) => TracerSpanOptions,\n    fn: T\n  ): T\n  public wrap(...args: Array<any>) {\n    const tracer = this\n    const [name, options, fn] =\n      args.length === 3 ? args : [args[0], {}, args[1]]\n\n    if (\n      !NextVanillaSpanAllowlist.includes(name) &&\n      process.env.NEXT_OTEL_VERBOSE !== '1'\n    ) {\n      return fn\n    }\n\n    return function (this: any) {\n      let optionsObj = options\n      if (typeof optionsObj === 'function' && typeof fn === 'function') {\n        optionsObj = optionsObj.apply(this, arguments)\n      }\n\n      const lastArgId = arguments.length - 1\n      const cb = arguments[lastArgId]\n\n      if (typeof cb === 'function') {\n        const scopeBoundCb = tracer.getContext().bind(context.active(), cb)\n        return tracer.trace(name, optionsObj, (_span, done) => {\n          arguments[lastArgId] = function (err: any) {\n            done?.(err)\n            return scopeBoundCb.apply(this, arguments)\n          }\n\n          return fn.apply(this, arguments)\n        })\n      } else {\n        return tracer.trace(name, optionsObj, () => fn.apply(this, arguments))\n      }\n    }\n  }\n\n  public startSpan(type: SpanTypes): Span\n  public startSpan(type: SpanTypes, options: TracerSpanOptions): Span\n  public startSpan(...args: Array<any>): Span {\n    const [type, options]: [string, TracerSpanOptions | undefined] = args as any\n\n    const spanContext = this.getSpanContext(\n      options?.parentSpan ?? this.getActiveScopeSpan()\n    )\n    return this.getTracerInstance().startSpan(type, options, spanContext)\n  }\n\n  private getSpanContext(parentSpan?: Span) {\n    const spanContext = parentSpan\n      ? trace.setSpan(context.active(), parentSpan)\n      : undefined\n\n    return spanContext\n  }\n\n  public getRootSpanAttributes() {\n    const spanId = context.active().getValue(rootSpanIdKey) as number\n    return rootSpanAttributesStore.get(spanId)\n  }\n\n  public setRootSpanAttribute(key: AttributeNames, value: AttributeValue) {\n    const spanId = context.active().getValue(rootSpanIdKey) as number\n    const attributes = rootSpanAttributesStore.get(spanId)\n    if (attributes && !attributes.has(key)) {\n      attributes.set(key, value)\n    }\n  }\n}\n\nconst getTracer = (() => {\n  const tracer = new NextTracerImpl()\n\n  return () => tracer\n})()\n\nexport { getTracer, SpanStatusCode, SpanKind }\nexport type { NextTracer, Span, SpanOptions, ContextAPI, TracerSpanOptions }\n","/**\n * A `Promise.withResolvers` implementation that exposes the `resolve` and\n * `reject` functions on a `Promise`.\n *\n * @see https://tc39.es/proposal-promise-with-resolvers/\n */\nexport class DetachedPromise<T = any> {\n  public readonly resolve: (value: T | PromiseLike<T>) => void\n  public readonly reject: (reason: any) => void\n  public readonly promise: Promise<T>\n\n  constructor() {\n    let resolve: (value: T | PromiseLike<T>) => void\n    let reject: (reason: any) => void\n\n    // Create the promise and assign the resolvers to the object.\n    this.promise = new Promise<T>((res, rej) => {\n      resolve = res\n      reject = rej\n    })\n\n    // We know that resolvers is defined because the Promise constructor runs\n    // synchronously.\n    this.resolve = resolve!\n    this.reject = reject!\n  }\n}\n","export type ScheduledFn<T = void> = () => T | PromiseLike<T>\nexport type SchedulerFn<T = void> = (cb: ScheduledFn<T>) => void\n\n/**\n * Schedules a function to be called on the next tick after the other promises\n * have been resolved.\n *\n * @param cb the function to schedule\n */\nexport const scheduleOnNextTick = (cb: ScheduledFn<void>) => {\n  // We use Promise.resolve().then() here so that the operation is scheduled at\n  // the end of the promise job queue, we then add it to the next process tick\n  // to ensure it's evaluated afterwards.\n  //\n  // This was inspired by the implementation of the DataLoader interface: https://github.com/graphql/dataloader/blob/d336bd15282664e0be4b4a657cb796f09bafbc6b/src/index.js#L213-L255\n  //\n  Promise.resolve().then(() => {\n    if (process.env.NEXT_RUNTIME === 'edge') {\n      setTimeout(cb, 0)\n    } else {\n      process.nextTick(cb)\n    }\n  })\n}\n\n/**\n * Schedules a function to be called using `setImmediate` or `setTimeout` if\n * `setImmediate` is not available (like in the Edge runtime).\n *\n * @param cb the function to schedule\n */\nexport const scheduleImmediate = (cb: ScheduledFn<void>): void => {\n  if (process.env.NEXT_RUNTIME === 'edge') {\n    setTimeout(cb, 0)\n  } else {\n    setImmediate(cb)\n  }\n}\n\n/**\n * returns a promise than resolves in a future task. There is no guarantee that the task it resolves in\n * will be the next task but if you await it you can at least be sure that the current task is over and\n * most usefully that the entire microtask queue of the current task has been emptied.\n */\nexport function atLeastOneTask() {\n  return new Promise<void>((resolve) => scheduleImmediate(resolve))\n}\n\n/**\n * This utility function is extracted to make it easier to find places where we are doing\n * specific timing tricks to try to schedule work after React has rendered. This is especially\n * important at the moment because Next.js uses the edge builds of React which use setTimeout to\n * schedule work when you might expect that something like setImmediate would do the trick.\n *\n * Long term we should switch to the node versions of React rendering when possible and then\n * update this to use setImmediate rather than setTimeout\n */\nexport function waitAtLeastOneReactRenderTask(): Promise<void> {\n  if (process.env.NEXT_RUNTIME === 'edge') {\n    return new Promise((r) => setTimeout(r, 0))\n  } else {\n    return new Promise((r) => setImmediate(r))\n  }\n}\n","export const ENCODED_TAGS = {\n  // opening tags do not have the closing `>` since they can contain other attributes such as `<body className=''>`\n  OPENING: {\n    // <html\n    HTML: new Uint8Array([60, 104, 116, 109, 108]),\n    // <body\n    BODY: new Uint8Array([60, 98, 111, 100, 121]),\n  },\n  CLOSED: {\n    // </head>\n    HEAD: new Uint8Array([60, 47, 104, 101, 97, 100, 62]),\n    // </body>\n    BODY: new Uint8Array([60, 47, 98, 111, 100, 121, 62]),\n    // </html>\n    HTML: new Uint8Array([60, 47, 104, 116, 109, 108, 62]),\n    // </body></html>\n    BODY_AND_HTML: new Uint8Array([\n      60, 47, 98, 111, 100, 121, 62, 60, 47, 104, 116, 109, 108, 62,\n    ]),\n  },\n  META: {\n    // Only the match the prefix cause the suffix can be different wether it's xml compatible or not \">\" or \"/>\"\n    // <meta name=\"«nxt-icon»\"\n    // This is a special mark that will be replaced by the icon insertion script tag.\n    ICON_MARK: new Uint8Array([\n      60, 109, 101, 116, 97, 32, 110, 97, 109, 101, 61, 34, 194, 171, 110, 120,\n      116, 45, 105, 99, 111, 110, 194, 187, 34,\n    ]),\n  },\n} as const\n","/**\n * Find the starting index of Uint8Array `b` within Uint8Array `a`.\n */\nexport function indexOfUint8Array(a: Uint8Array, b: Uint8Array) {\n  if (b.length === 0) return 0\n  if (a.length === 0 || b.length > a.length) return -1\n\n  // start iterating through `a`\n  for (let i = 0; i <= a.length - b.length; i++) {\n    let completeMatch = true\n    // from index `i`, iterate through `b` and check for mismatch\n    for (let j = 0; j < b.length; j++) {\n      // if the values do not match, then this isn't a complete match, exit `b` iteration early and iterate to next index of `a`.\n      if (a[i + j] !== b[j]) {\n        completeMatch = false\n        break\n      }\n    }\n\n    if (completeMatch) {\n      return i\n    }\n  }\n\n  return -1\n}\n\n/**\n * Check if two Uint8Arrays are strictly equivalent.\n */\nexport function isEquivalentUint8Arrays(a: Uint8Array, b: Uint8Array) {\n  if (a.length !== b.length) return false\n\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) return false\n  }\n\n  return true\n}\n\n/**\n * Remove Uint8Array `b` from Uint8Array `a`.\n *\n * If `b` is not in `a`, `a` is returned unchanged.\n *\n * Otherwise, the function returns a new Uint8Array instance with size `a.length - b.length`\n */\nexport function removeFromUint8Array(a: Uint8Array, b: Uint8Array) {\n  const tagIndex = indexOfUint8Array(a, b)\n  if (tagIndex === 0) return a.subarray(b.length)\n  if (tagIndex > -1) {\n    const removed = new Uint8Array(a.length - b.length)\n    removed.set(a.slice(0, tagIndex))\n    removed.set(a.slice(tagIndex + b.length), tagIndex)\n    return removed\n  } else {\n    return a\n  }\n}\n","export const MISSING_ROOT_TAGS_ERROR = 'NEXT_MISSING_ROOT_TAGS'\n","// In output: export mode, the build id is added to the start of the HTML\n// document, directly after the doctype declaration. During a prefetch, the\n// client performs a range request to get the build id, so it can check whether\n// the target page belongs to the same build.\n//\n// The first 64 bytes of the document are requested. The exact number isn't\n// too important; it must be larger than the build id + doctype + closing and\n// ending comment markers, but it doesn't need to match the end of the\n// comment exactly.\n//\n// Build ids are 21 bytes long in the default implementation, though this\n// can be overridden in the Next.js config. For the purposes of this check,\n// it's OK to only match the start of the id, so we'll truncate it if exceeds\n// a certain length.\n\nconst DOCTYPE_PREFIX = '<!DOCTYPE html>' // 15 bytes\nconst MAX_BUILD_ID_LENGTH = 24\n\n// Request the first 64 bytes. The Range header is inclusive of the end value.\nexport const DOC_PREFETCH_RANGE_HEADER_VALUE = 'bytes=0-63'\n\nfunction escapeBuildId(buildId: string) {\n  // If the build id is longer than the given limit, it's OK for our purposes\n  // to only match the beginning.\n  const truncated = buildId.slice(0, MAX_BUILD_ID_LENGTH)\n  // Replace hyphens with underscores so it doesn't break the HTML comment.\n  // (Unlikely, but if this did happen it would break the whole document.)\n  return truncated.replace(/-/g, '_')\n}\n\nexport function insertBuildIdComment(originalHtml: string, buildId: string) {\n  if (\n    // Skip if the build id contains a closing comment marker.\n    buildId.includes('-->') ||\n    // React always inserts a doctype at the start of the document. Skip if it\n    // isn't present. Shouldn't happen; suggests an issue elsewhere.\n    !originalHtml.startsWith(DOCTYPE_PREFIX)\n  ) {\n    // Return the original HTML unchanged. This means the document will not\n    // be prefetched.\n    // TODO: The build id comment is currently only used during prefetches, but\n    // if we eventually use this mechanism for regular navigations, we may need\n    // to error during build if we fail to insert it for some reason.\n    return originalHtml\n  }\n  // The comment must be inserted after the doctype.\n  return originalHtml.replace(\n    DOCTYPE_PREFIX,\n    DOCTYPE_PREFIX + '<!--' + escapeBuildId(buildId) + '-->'\n  )\n}\n\nexport function doesExportedHtmlMatchBuildId(\n  partialHtmlDocument: string,\n  buildId: string\n) {\n  // Check whether the document starts with the expected buildId.\n  return partialHtmlDocument.startsWith(\n    DOCTYPE_PREFIX + '<!--' + escapeBuildId(buildId) + '-->'\n  )\n}\n","export const RSC_HEADER = 'rsc' as const\nexport const ACTION_HEADER = 'next-action' as const\n// TODO: Instead of sending the full router state, we only need to send the\n// segment path. Saves bytes. Then we could also use this field for segment\n// prefetches, which also need to specify a particular segment.\nexport const NEXT_ROUTER_STATE_TREE_HEADER = 'next-router-state-tree' as const\nexport const NEXT_ROUTER_PREFETCH_HEADER = 'next-router-prefetch' as const\n// This contains the path to the segment being prefetched.\n// TODO: If we change next-router-state-tree to be a segment path, we can use\n// that instead. Then next-router-prefetch and next-router-segment-prefetch can\n// be merged into a single enum.\nexport const NEXT_ROUTER_SEGMENT_PREFETCH_HEADER =\n  'next-router-segment-prefetch' as const\nexport const NEXT_HMR_REFRESH_HEADER = 'next-hmr-refresh' as const\nexport const NEXT_HMR_REFRESH_HASH_COOKIE = '__next_hmr_refresh_hash__' as const\nexport const NEXT_URL = 'next-url' as const\nexport const RSC_CONTENT_TYPE_HEADER = 'text/x-component' as const\n\nexport const FLIGHT_HEADERS = [\n  RSC_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_HMR_REFRESH_HEADER,\n  NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,\n] as const\n\nexport const NEXT_RSC_UNION_QUERY = '_rsc' as const\n\nexport const NEXT_ROUTER_STALE_TIME_HEADER = 'x-nextjs-stale-time' as const\nexport const NEXT_DID_POSTPONE_HEADER = 'x-nextjs-postponed' as const\nexport const NEXT_REWRITTEN_PATH_HEADER = 'x-nextjs-rewritten-path' as const\nexport const NEXT_REWRITTEN_QUERY_HEADER = 'x-nextjs-rewritten-query' as const\nexport const NEXT_IS_PRERENDER_HEADER = 'x-nextjs-prerender' as const\nexport const NEXT_ACTION_NOT_FOUND_HEADER = 'x-nextjs-action-not-found' as const\nexport const NEXT_REQUEST_ID_HEADER = 'x-nextjs-request-id' as const\nexport const NEXT_HTML_REQUEST_ID_HEADER = 'x-nextjs-html-request-id' as const\n","// http://www.cse.yorku.ca/~oz/hash.html\n// More specifically, 32-bit hash via djbxor\n// (ref: https://gist.github.com/eplawless/52813b1d8ad9af510d85?permalink_comment_id=3367765#gistcomment-3367765)\n// This is due to number type differences between rust for turbopack to js number types,\n// where rust does not have easy way to repreesnt js's 53-bit float number type for the matching\n// overflow behavior. This is more `correct` in terms of having canonical hash across different runtime / implementation\n// as can gaurantee determinstic output from 32bit hash.\nexport function djb2Hash(str: string) {\n  let hash = 5381\n  for (let i = 0; i < str.length; i++) {\n    const char = str.charCodeAt(i)\n    hash = ((hash << 5) + hash + char) & 0xffffffff\n  }\n  return hash >>> 0\n}\n\nexport function hexHash(str: string) {\n  return djb2Hash(str).toString(36).slice(0, 5)\n}\n","import { hexHash } from '../../hash'\n\nexport function computeCacheBustingSearchParam(\n  prefetchHeader: '1' | '2' | '0' | undefined,\n  segmentPrefetchHeader: string | string[] | undefined,\n  stateTreeHeader: string | string[] | undefined,\n  nextUrlHeader: string | string[] | undefined\n): string {\n  if (\n    (prefetchHeader === undefined || prefetchHeader === '0') &&\n    segmentPrefetchHeader === undefined &&\n    stateTreeHeader === undefined &&\n    nextUrlHeader === undefined\n  ) {\n    return ''\n  }\n  return hexHash(\n    [\n      prefetchHeader || '0',\n      segmentPrefetchHeader || '0',\n      stateTreeHeader || '0',\n      nextUrlHeader || '0',\n    ].join(',')\n  )\n}\n","import type { ReactDOMServerReadableStream } from 'react-dom/server'\nimport { getTracer } from '../lib/trace/tracer'\nimport { AppRenderSpan } from '../lib/trace/constants'\nimport { DetachedPromise } from '../../lib/detached-promise'\nimport { scheduleImmediate, atLeastOneTask } from '../../lib/scheduler'\nimport { ENCODED_TAGS } from './encoded-tags'\nimport {\n  indexOfUint8Array,\n  isEquivalentUint8Arrays,\n  removeFromUint8Array,\n} from './uint8array-helpers'\nimport { MISSING_ROOT_TAGS_ERROR } from '../../shared/lib/errors/constants'\nimport { insertBuildIdComment } from '../../shared/lib/segment-cache/output-export-prefetch-encoding'\nimport {\n  RSC_HEADER,\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,\n  NEXT_RSC_UNION_QUERY,\n} from '../../client/components/app-router-headers'\nimport { computeCacheBustingSearchParam } from '../../shared/lib/router/utils/cache-busting-search-param'\n\nfunction voidCatch() {\n  // this catcher is designed to be used with pipeTo where we expect the underlying\n  // pipe implementation to forward errors but we don't want the pipeTo promise to reject\n  // and be unhandled\n}\n\n// We can share the same encoder instance everywhere\n// Notably we cannot do the same for TextDecoder because it is stateful\n// when handling streaming data\nconst encoder = new TextEncoder()\n\nexport function chainStreams<T>(\n  ...streams: ReadableStream<T>[]\n): ReadableStream<T> {\n  // If we have no streams, return an empty stream. This behavior is\n  // intentional as we're now providing the `RenderResult.EMPTY` value.\n  if (streams.length === 0) {\n    return new ReadableStream<T>({\n      start(controller) {\n        controller.close()\n      },\n    })\n  }\n\n  // If we only have 1 stream we fast path it by returning just this stream\n  if (streams.length === 1) {\n    return streams[0]\n  }\n\n  const { readable, writable } = new TransformStream()\n\n  // We always initiate pipeTo immediately. We know we have at least 2 streams\n  // so we need to avoid closing the writable when this one finishes.\n  let promise = streams[0].pipeTo(writable, { preventClose: true })\n\n  let i = 1\n  for (; i < streams.length - 1; i++) {\n    const nextStream = streams[i]\n    promise = promise.then(() =>\n      nextStream.pipeTo(writable, { preventClose: true })\n    )\n  }\n\n  // We can omit the length check because we halted before the last stream and there\n  // is at least two streams so the lastStream here will always be defined\n  const lastStream = streams[i]\n  promise = promise.then(() => lastStream.pipeTo(writable))\n\n  // Catch any errors from the streams and ignore them, they will be handled\n  // by whatever is consuming the readable stream.\n  promise.catch(voidCatch)\n\n  return readable\n}\n\nexport function streamFromString(str: string): ReadableStream<Uint8Array> {\n  return new ReadableStream({\n    start(controller) {\n      controller.enqueue(encoder.encode(str))\n      controller.close()\n    },\n  })\n}\n\nexport function streamFromBuffer(chunk: Buffer): ReadableStream<Uint8Array> {\n  return new ReadableStream({\n    start(controller) {\n      controller.enqueue(chunk)\n      controller.close()\n    },\n  })\n}\n\nexport async function streamToBuffer(\n  stream: ReadableStream<Uint8Array>\n): Promise<Buffer> {\n  const reader = stream.getReader()\n  const chunks: Uint8Array[] = []\n\n  while (true) {\n    const { done, value } = await reader.read()\n    if (done) {\n      break\n    }\n\n    chunks.push(value)\n  }\n\n  return Buffer.concat(chunks)\n}\n\nexport async function streamToString(\n  stream: ReadableStream<Uint8Array>,\n  signal?: AbortSignal\n): Promise<string> {\n  const decoder = new TextDecoder('utf-8', { fatal: true })\n  let string = ''\n\n  for await (const chunk of stream) {\n    if (signal?.aborted) {\n      return string\n    }\n\n    string += decoder.decode(chunk, { stream: true })\n  }\n\n  string += decoder.decode()\n\n  return string\n}\n\nexport type BufferedTransformOptions = {\n  /**\n   * Flush synchronously once the buffer reaches this many bytes.\n   */\n  readonly maxBufferByteLength?: number\n}\n\nexport function createBufferedTransformStream(\n  options: BufferedTransformOptions = {}\n): TransformStream<Uint8Array, Uint8Array> {\n  const { maxBufferByteLength = Infinity } = options\n\n  let bufferedChunks: Array<Uint8Array> = []\n  let bufferByteLength: number = 0\n  let pending: DetachedPromise<void> | undefined\n\n  const flush = (controller: TransformStreamDefaultController) => {\n    try {\n      if (bufferedChunks.length === 0) {\n        return\n      }\n\n      const chunk = new Uint8Array(bufferByteLength)\n      let copiedBytes = 0\n\n      for (let i = 0; i < bufferedChunks.length; i++) {\n        const bufferedChunk = bufferedChunks[i]\n        chunk.set(bufferedChunk, copiedBytes)\n        copiedBytes += bufferedChunk.byteLength\n      }\n      // We just wrote all the buffered chunks so we need to reset the bufferedChunks array\n      // and our bufferByteLength to prepare for the next round of buffered chunks\n      bufferedChunks.length = 0\n      bufferByteLength = 0\n      controller.enqueue(chunk)\n    } catch {\n      // If an error occurs while enqueuing, it can't be due to this\n      // transformer. It's most likely caused by the controller having been\n      // errored (for example, if the stream was cancelled).\n    }\n  }\n\n  const scheduleFlush = (controller: TransformStreamDefaultController) => {\n    if (pending) {\n      return\n    }\n\n    const detached = new DetachedPromise<void>()\n    pending = detached\n\n    scheduleImmediate(() => {\n      try {\n        flush(controller)\n      } finally {\n        pending = undefined\n        detached.resolve()\n      }\n    })\n  }\n\n  return new TransformStream({\n    transform(chunk, controller) {\n      // Combine the previous buffer with the new chunk.\n      bufferedChunks.push(chunk)\n      bufferByteLength += chunk.byteLength\n\n      if (bufferByteLength >= maxBufferByteLength) {\n        flush(controller)\n      } else {\n        scheduleFlush(controller)\n      }\n    },\n    flush() {\n      return pending?.promise\n    },\n  })\n}\n\nfunction createPrefetchCommentStream(\n  isBuildTimePrerendering: boolean,\n  buildId: string\n): TransformStream<Uint8Array, Uint8Array> {\n  // Insert an extra comment at the beginning of the HTML document. This must\n  // come after the DOCTYPE, which is inserted by React.\n  //\n  // The first chunk sent by React will contain the doctype. After that, we can\n  // pass through the rest of the chunks as-is.\n  let didTransformFirstChunk = false\n  return new TransformStream({\n    transform(chunk, controller) {\n      if (isBuildTimePrerendering && !didTransformFirstChunk) {\n        didTransformFirstChunk = true\n        const decoder = new TextDecoder('utf-8', { fatal: true })\n        const chunkStr = decoder.decode(chunk, {\n          stream: true,\n        })\n        const updatedChunkStr = insertBuildIdComment(chunkStr, buildId)\n        controller.enqueue(encoder.encode(updatedChunkStr))\n        return\n      }\n      controller.enqueue(chunk)\n    },\n  })\n}\n\nexport function renderToInitialFizzStream({\n  ReactDOMServer,\n  element,\n  streamOptions,\n}: {\n  ReactDOMServer: {\n    renderToReadableStream: typeof import('react-dom/server').renderToReadableStream\n  }\n  element: React.ReactElement\n  streamOptions?: Parameters<typeof ReactDOMServer.renderToReadableStream>[1]\n}): Promise<ReactDOMServerReadableStream> {\n  return getTracer().trace(AppRenderSpan.renderToReadableStream, async () =>\n    ReactDOMServer.renderToReadableStream(element, streamOptions)\n  )\n}\n\nfunction createMetadataTransformStream(\n  insert: () => Promise<string> | string\n): TransformStream<Uint8Array, Uint8Array> {\n  let chunkIndex = -1\n  let isMarkRemoved = false\n\n  return new TransformStream({\n    async transform(chunk, controller) {\n      let iconMarkIndex = -1\n      let closedHeadIndex = -1\n      chunkIndex++\n\n      if (isMarkRemoved) {\n        controller.enqueue(chunk)\n        return\n      }\n      let iconMarkLength = 0\n      // Only search for the closed head tag once\n      if (iconMarkIndex === -1) {\n        iconMarkIndex = indexOfUint8Array(chunk, ENCODED_TAGS.META.ICON_MARK)\n        if (iconMarkIndex === -1) {\n          controller.enqueue(chunk)\n          return\n        } else {\n          // When we found the `<meta name=\"«nxt-icon»\"` tag prefix, we will remove it from the chunk.\n          // Its close tag could either be `/>` or `>`, checking the next char to ensure we cover both cases.\n          iconMarkLength = ENCODED_TAGS.META.ICON_MARK.length\n          // Check if next char is /, this is for xml mode.\n          if (chunk[iconMarkIndex + iconMarkLength] === 47) {\n            iconMarkLength += 2\n          } else {\n            // The last char is `>`\n            iconMarkLength++\n          }\n        }\n      }\n\n      // Check if icon mark is inside <head> tag in the first chunk.\n      if (chunkIndex === 0) {\n        closedHeadIndex = indexOfUint8Array(chunk, ENCODED_TAGS.CLOSED.HEAD)\n        if (iconMarkIndex !== -1) {\n          // The mark icon is located in the 1st chunk before the head tag.\n          // We do not need to insert the script tag in this case because it's in the head.\n          // Just remove the icon mark from the chunk.\n          if (iconMarkIndex < closedHeadIndex) {\n            const replaced = new Uint8Array(chunk.length - iconMarkLength)\n\n            // Remove the icon mark from the chunk.\n            replaced.set(chunk.subarray(0, iconMarkIndex))\n            replaced.set(\n              chunk.subarray(iconMarkIndex + iconMarkLength),\n              iconMarkIndex\n            )\n            chunk = replaced\n          } else {\n            // The icon mark is after the head tag, replace and insert the script tag at that position.\n            const insertion = await insert()\n            const encodedInsertion = encoder.encode(insertion)\n            const insertionLength = encodedInsertion.length\n            const replaced = new Uint8Array(\n              chunk.length - iconMarkLength + insertionLength\n            )\n            replaced.set(chunk.subarray(0, iconMarkIndex))\n            replaced.set(encodedInsertion, iconMarkIndex)\n            replaced.set(\n              chunk.subarray(iconMarkIndex + iconMarkLength),\n              iconMarkIndex + insertionLength\n            )\n            chunk = replaced\n          }\n          isMarkRemoved = true\n        }\n        // If there's no icon mark located, it will be handled later when if present in the following chunks.\n      } else {\n        // When it's appeared in the following chunks, we'll need to\n        // remove the mark and then insert the script tag at that position.\n        const insertion = await insert()\n        const encodedInsertion = encoder.encode(insertion)\n        const insertionLength = encodedInsertion.length\n        // Replace the icon mark with the hoist script or empty string.\n        const replaced = new Uint8Array(\n          chunk.length - iconMarkLength + insertionLength\n        )\n        // Set the first part of the chunk, before the icon mark.\n        replaced.set(chunk.subarray(0, iconMarkIndex))\n        // Set the insertion after the icon mark.\n        replaced.set(encodedInsertion, iconMarkIndex)\n\n        // Set the rest of the chunk after the icon mark.\n        replaced.set(\n          chunk.subarray(iconMarkIndex + iconMarkLength),\n          iconMarkIndex + insertionLength\n        )\n        chunk = replaced\n        isMarkRemoved = true\n      }\n      controller.enqueue(chunk)\n    },\n  })\n}\n\nfunction createHeadInsertionTransformStream(\n  insert: () => Promise<string>\n): TransformStream<Uint8Array, Uint8Array> {\n  let inserted = false\n\n  // We need to track if this transform saw any bytes because if it didn't\n  // we won't want to insert any server HTML at all\n  let hasBytes = false\n\n  return new TransformStream({\n    async transform(chunk, controller) {\n      hasBytes = true\n\n      const insertion = await insert()\n      if (inserted) {\n        if (insertion) {\n          const encodedInsertion = encoder.encode(insertion)\n          controller.enqueue(encodedInsertion)\n        }\n        controller.enqueue(chunk)\n      } else {\n        // TODO (@Ethan-Arrowood): Replace the generic `indexOfUint8Array` method with something finely tuned for the subset of things actually being checked for.\n        const index = indexOfUint8Array(chunk, ENCODED_TAGS.CLOSED.HEAD)\n        // In fully static rendering or non PPR rendering cases:\n        // `/head>` will always be found in the chunk in first chunk rendering.\n        if (index !== -1) {\n          if (insertion) {\n            const encodedInsertion = encoder.encode(insertion)\n            // Get the total count of the bytes in the chunk and the insertion\n            // e.g.\n            // chunk = <head><meta charset=\"utf-8\"></head>\n            // insertion = <script>...</script>\n            // output = <head><meta charset=\"utf-8\"> [ <script>...</script> ] </head>\n            const insertedHeadContent = new Uint8Array(\n              chunk.length + encodedInsertion.length\n            )\n            // Append the first part of the chunk, before the head tag\n            insertedHeadContent.set(chunk.slice(0, index))\n            // Append the server inserted content\n            insertedHeadContent.set(encodedInsertion, index)\n            // Append the rest of the chunk\n            insertedHeadContent.set(\n              chunk.slice(index),\n              index + encodedInsertion.length\n            )\n            controller.enqueue(insertedHeadContent)\n          } else {\n            controller.enqueue(chunk)\n          }\n          inserted = true\n        } else {\n          // This will happens in PPR rendering during next start, when the page is partially rendered.\n          // When the page resumes, the head tag will be found in the middle of the chunk.\n          // Where we just need to append the insertion and chunk to the current stream.\n          // e.g.\n          // PPR-static: <head>...</head><body> [ resume content ] </body>\n          // PPR-resume: [ insertion ] [ rest content ]\n          if (insertion) {\n            controller.enqueue(encoder.encode(insertion))\n          }\n          controller.enqueue(chunk)\n          inserted = true\n        }\n      }\n    },\n    async flush(controller) {\n      // Check before closing if there's anything remaining to insert.\n      if (hasBytes) {\n        const insertion = await insert()\n        if (insertion) {\n          controller.enqueue(encoder.encode(insertion))\n        }\n      }\n    },\n  })\n}\n\nfunction createClientResumeScriptInsertionTransformStream(): TransformStream<\n  Uint8Array,\n  Uint8Array\n> {\n  const segmentPath = '/_full'\n  const cacheBustingHeader = computeCacheBustingSearchParam(\n    '1', //            headers[NEXT_ROUTER_PREFETCH_HEADER]\n    '/_full', //       headers[NEXT_ROUTER_SEGMENT_PREFETCH_HEADER]\n    undefined, //      headers[NEXT_ROUTER_STATE_TREE_HEADER]\n    undefined //       headers[NEXT_URL]\n  )\n  const searchStr = `${NEXT_RSC_UNION_QUERY}=${cacheBustingHeader}`\n  const NEXT_CLIENT_RESUME_SCRIPT = `<script>__NEXT_CLIENT_RESUME=fetch(location.pathname+'?${searchStr}',{credentials:'same-origin',headers:{'${RSC_HEADER}': '1','${NEXT_ROUTER_PREFETCH_HEADER}': '1','${NEXT_ROUTER_SEGMENT_PREFETCH_HEADER}': '${segmentPath}'}})</script>`\n\n  let didAlreadyInsert = false\n  return new TransformStream({\n    transform(chunk, controller) {\n      if (didAlreadyInsert) {\n        // Already inserted the script into the head. Pass through.\n        controller.enqueue(chunk)\n        return\n      }\n      // TODO (@Ethan-Arrowood): Replace the generic `indexOfUint8Array` method with something finely tuned for the subset of things actually being checked for.\n      const headClosingTagIndex = indexOfUint8Array(\n        chunk,\n        ENCODED_TAGS.CLOSED.HEAD\n      )\n\n      if (headClosingTagIndex === -1) {\n        // In fully static rendering or non PPR rendering cases:\n        // `/head>` will always be found in the chunk in first chunk rendering.\n        controller.enqueue(chunk)\n        return\n      }\n\n      const encodedInsertion = encoder.encode(NEXT_CLIENT_RESUME_SCRIPT)\n      // Get the total count of the bytes in the chunk and the insertion\n      // e.g.\n      // chunk = <head><meta charset=\"utf-8\"></head>\n      // insertion = <script>...</script>\n      // output = <head><meta charset=\"utf-8\"> [ <script>...</script> ] </head>\n      const insertedHeadContent = new Uint8Array(\n        chunk.length + encodedInsertion.length\n      )\n      // Append the first part of the chunk, before the head tag\n      insertedHeadContent.set(chunk.slice(0, headClosingTagIndex))\n      // Append the server inserted content\n      insertedHeadContent.set(encodedInsertion, headClosingTagIndex)\n      // Append the rest of the chunk\n      insertedHeadContent.set(\n        chunk.slice(headClosingTagIndex),\n        headClosingTagIndex + encodedInsertion.length\n      )\n\n      controller.enqueue(insertedHeadContent)\n      didAlreadyInsert = true\n    },\n  })\n}\n\n// Suffix after main body content - scripts before </body>,\n// but wait for the major chunks to be enqueued.\nfunction createDeferredSuffixStream(\n  suffix: string\n): TransformStream<Uint8Array, Uint8Array> {\n  let flushed = false\n  let pending: DetachedPromise<void> | undefined\n\n  const flush = (controller: TransformStreamDefaultController) => {\n    const detached = new DetachedPromise<void>()\n    pending = detached\n\n    scheduleImmediate(() => {\n      try {\n        controller.enqueue(encoder.encode(suffix))\n      } catch {\n        // If an error occurs while enqueuing it can't be due to this\n        // transformers fault. It's likely due to the controller being\n        // errored due to the stream being cancelled.\n      } finally {\n        pending = undefined\n        detached.resolve()\n      }\n    })\n  }\n\n  return new TransformStream({\n    transform(chunk, controller) {\n      controller.enqueue(chunk)\n\n      // If we've already flushed, we're done.\n      if (flushed) return\n\n      // Schedule the flush to happen.\n      flushed = true\n      flush(controller)\n    },\n    flush(controller) {\n      if (pending) return pending.promise\n      if (flushed) return\n\n      // Flush now.\n      controller.enqueue(encoder.encode(suffix))\n    },\n  })\n}\n\nfunction createFlightDataInjectionTransformStream(\n  stream: ReadableStream<Uint8Array>,\n  delayDataUntilFirstHtmlChunk: boolean\n): TransformStream<Uint8Array, Uint8Array> {\n  let htmlStreamFinished = false\n\n  let pull: Promise<void> | null = null\n  let donePulling = false\n\n  function startOrContinuePulling(\n    controller: TransformStreamDefaultController\n  ) {\n    if (!pull) {\n      pull = startPulling(controller)\n    }\n    return pull\n  }\n\n  async function startPulling(controller: TransformStreamDefaultController) {\n    const reader = stream.getReader()\n\n    if (delayDataUntilFirstHtmlChunk) {\n      // NOTE: streaming flush\n      // We are buffering here for the inlined data stream because the\n      // \"shell\" stream might be chunkenized again by the underlying stream\n      // implementation, e.g. with a specific high-water mark. To ensure it's\n      // the safe timing to pipe the data stream, this extra tick is\n      // necessary.\n\n      // We don't start reading until we've left the current Task to ensure\n      // that it's inserted after flushing the shell. Note that this implementation\n      // might get stale if impl details of Fizz change in the future.\n      await atLeastOneTask()\n    }\n\n    try {\n      while (true) {\n        const { done, value } = await reader.read()\n        if (done) {\n          donePulling = true\n          return\n        }\n\n        // We want to prioritize HTML over RSC data.\n        // The SSR render is based on the same RSC stream, so when we get a new RSC chunk,\n        // we're likely to produce an HTML chunk as well, so give it a chance to flush first.\n        if (!delayDataUntilFirstHtmlChunk && !htmlStreamFinished) {\n          await atLeastOneTask()\n        }\n        controller.enqueue(value)\n      }\n    } catch (err) {\n      controller.error(err)\n    }\n  }\n\n  return new TransformStream({\n    start(controller) {\n      if (!delayDataUntilFirstHtmlChunk) {\n        startOrContinuePulling(controller)\n      }\n    },\n    transform(chunk, controller) {\n      controller.enqueue(chunk)\n\n      // Start the streaming if it hasn't already been started yet.\n      if (delayDataUntilFirstHtmlChunk) {\n        startOrContinuePulling(controller)\n      }\n    },\n    flush(controller) {\n      htmlStreamFinished = true\n      if (donePulling) {\n        return\n      }\n      return startOrContinuePulling(controller)\n    },\n  })\n}\n\nconst CLOSE_TAG = '</body></html>'\n\n/**\n * This transform stream moves the suffix to the end of the stream, so results\n * like `</body></html><script>...</script>` will be transformed to\n * `<script>...</script></body></html>`.\n */\nfunction createMoveSuffixStream(): TransformStream<Uint8Array, Uint8Array> {\n  let foundSuffix = false\n\n  return new TransformStream({\n    transform(chunk, controller) {\n      if (foundSuffix) {\n        return controller.enqueue(chunk)\n      }\n\n      const index = indexOfUint8Array(chunk, ENCODED_TAGS.CLOSED.BODY_AND_HTML)\n      if (index > -1) {\n        foundSuffix = true\n\n        // If the whole chunk is the suffix, then don't write anything, it will\n        // be written in the flush.\n        if (chunk.length === ENCODED_TAGS.CLOSED.BODY_AND_HTML.length) {\n          return\n        }\n\n        // Write out the part before the suffix.\n        const before = chunk.slice(0, index)\n        controller.enqueue(before)\n\n        // In the case where the suffix is in the middle of the chunk, we need\n        // to split the chunk into two parts.\n        if (chunk.length > ENCODED_TAGS.CLOSED.BODY_AND_HTML.length + index) {\n          // Write out the part after the suffix.\n          const after = chunk.slice(\n            index + ENCODED_TAGS.CLOSED.BODY_AND_HTML.length\n          )\n          controller.enqueue(after)\n        }\n      } else {\n        controller.enqueue(chunk)\n      }\n    },\n    flush(controller) {\n      // Even if we didn't find the suffix, the HTML is not valid if we don't\n      // add it, so insert it at the end.\n      controller.enqueue(ENCODED_TAGS.CLOSED.BODY_AND_HTML)\n    },\n  })\n}\n\nfunction createStripDocumentClosingTagsTransform(): TransformStream<\n  Uint8Array,\n  Uint8Array\n> {\n  return new TransformStream({\n    transform(chunk, controller) {\n      // We rely on the assumption that chunks will never break across a code unit.\n      // This is reasonable because we currently concat all of React's output from a single\n      // flush into one chunk before streaming it forward which means the chunk will represent\n      // a single coherent utf-8 string. This is not safe to use if we change our streaming to no\n      // longer do this large buffered chunk\n      if (\n        isEquivalentUint8Arrays(chunk, ENCODED_TAGS.CLOSED.BODY_AND_HTML) ||\n        isEquivalentUint8Arrays(chunk, ENCODED_TAGS.CLOSED.BODY) ||\n        isEquivalentUint8Arrays(chunk, ENCODED_TAGS.CLOSED.HTML)\n      ) {\n        // the entire chunk is the closing tags; return without enqueueing anything.\n        return\n      }\n\n      // We assume these tags will go at together at the end of the document and that\n      // they won't appear anywhere else in the document. This is not really a safe assumption\n      // but until we revamp our streaming infra this is a performant way to string the tags\n      chunk = removeFromUint8Array(chunk, ENCODED_TAGS.CLOSED.BODY)\n      chunk = removeFromUint8Array(chunk, ENCODED_TAGS.CLOSED.HTML)\n\n      controller.enqueue(chunk)\n    },\n  })\n}\n\n/*\n * Checks if the root layout is missing the html or body tags\n * and if so, it will inject a script tag to throw an error in the browser, showing the user\n * the error message in the error overlay.\n */\nexport function createRootLayoutValidatorStream(): TransformStream<\n  Uint8Array,\n  Uint8Array\n> {\n  let foundHtml = false\n  let foundBody = false\n  return new TransformStream({\n    async transform(chunk, controller) {\n      // Peek into the streamed chunk to see if the tags are present.\n      if (\n        !foundHtml &&\n        indexOfUint8Array(chunk, ENCODED_TAGS.OPENING.HTML) > -1\n      ) {\n        foundHtml = true\n      }\n\n      if (\n        !foundBody &&\n        indexOfUint8Array(chunk, ENCODED_TAGS.OPENING.BODY) > -1\n      ) {\n        foundBody = true\n      }\n\n      controller.enqueue(chunk)\n    },\n    flush(controller) {\n      const missingTags: ('html' | 'body')[] = []\n      if (!foundHtml) missingTags.push('html')\n      if (!foundBody) missingTags.push('body')\n\n      if (!missingTags.length) return\n\n      controller.enqueue(\n        encoder.encode(\n          `<html id=\"__next_error__\">\n            <template\n              data-next-error-message=\"Missing ${missingTags\n                .map((c) => `<${c}>`)\n                .join(\n                  missingTags.length > 1 ? ' and ' : ''\n                )} tags in the root layout.\\nRead more at https://nextjs.org/docs/messages/missing-root-layout-tags\"\n              data-next-error-digest=\"${MISSING_ROOT_TAGS_ERROR}\"\n              data-next-error-stack=\"\"\n            ></template>\n          `\n        )\n      )\n    },\n  })\n}\n\nfunction chainTransformers<T>(\n  readable: ReadableStream<T>,\n  transformers: ReadonlyArray<TransformStream<T, T> | null>\n): ReadableStream<T> {\n  let stream = readable\n  for (const transformer of transformers) {\n    if (!transformer) continue\n\n    stream = stream.pipeThrough(transformer)\n  }\n  return stream\n}\n\nexport type ContinueStreamOptions = {\n  inlinedDataStream: ReadableStream<Uint8Array> | undefined\n  isStaticGeneration: boolean\n  isBuildTimePrerendering: boolean\n  buildId: string\n  getServerInsertedHTML: () => Promise<string>\n  getServerInsertedMetadata: () => Promise<string>\n  validateRootLayout?: boolean\n  /**\n   * Suffix to inject after the buffered data, but before the close tags.\n   */\n  suffix?: string | undefined\n}\n\nexport async function continueFizzStream(\n  renderStream: ReactDOMServerReadableStream,\n  {\n    suffix,\n    inlinedDataStream,\n    isStaticGeneration,\n    isBuildTimePrerendering,\n    buildId,\n    getServerInsertedHTML,\n    getServerInsertedMetadata,\n    validateRootLayout,\n  }: ContinueStreamOptions\n): Promise<ReadableStream<Uint8Array>> {\n  // Suffix itself might contain close tags at the end, so we need to split it.\n  const suffixUnclosed = suffix ? suffix.split(CLOSE_TAG, 1)[0] : null\n\n  // If we're generating static HTML we need to wait for it to resolve before continuing.\n  if (isStaticGeneration) {\n    await renderStream.allReady\n  }\n\n  return chainTransformers(renderStream, [\n    // Buffer everything to avoid flushing too frequently\n    createBufferedTransformStream(),\n\n    // Add build id comment to start of the HTML document (in export mode)\n    createPrefetchCommentStream(isBuildTimePrerendering, buildId),\n\n    // Transform metadata\n    createMetadataTransformStream(getServerInsertedMetadata),\n\n    // Insert suffix content\n    suffixUnclosed != null && suffixUnclosed.length > 0\n      ? createDeferredSuffixStream(suffixUnclosed)\n      : null,\n\n    // Insert the inlined data (Flight data, form state, etc.) stream into the HTML\n    inlinedDataStream\n      ? createFlightDataInjectionTransformStream(inlinedDataStream, true)\n      : null,\n\n    // Validate the root layout for missing html or body tags\n    validateRootLayout ? createRootLayoutValidatorStream() : null,\n\n    // Close tags should always be deferred to the end\n    createMoveSuffixStream(),\n\n    // Special head insertions\n    // TODO-APP: Insert server side html to end of head in app layout rendering, to avoid\n    // hydration errors. Remove this once it's ready to be handled by react itself.\n    createHeadInsertionTransformStream(getServerInsertedHTML),\n  ])\n}\n\ntype ContinueDynamicPrerenderOptions = {\n  getServerInsertedHTML: () => Promise<string>\n  getServerInsertedMetadata: () => Promise<string>\n}\n\nexport async function continueDynamicPrerender(\n  prerenderStream: ReadableStream<Uint8Array>,\n  {\n    getServerInsertedHTML,\n    getServerInsertedMetadata,\n  }: ContinueDynamicPrerenderOptions\n) {\n  return (\n    prerenderStream\n      // Buffer everything to avoid flushing too frequently\n      .pipeThrough(createBufferedTransformStream())\n      .pipeThrough(createStripDocumentClosingTagsTransform())\n      // Insert generated tags to head\n      .pipeThrough(createHeadInsertionTransformStream(getServerInsertedHTML))\n      // Transform metadata\n      .pipeThrough(createMetadataTransformStream(getServerInsertedMetadata))\n  )\n}\n\ntype ContinueStaticPrerenderOptions = {\n  inlinedDataStream: ReadableStream<Uint8Array>\n  getServerInsertedHTML: () => Promise<string>\n  getServerInsertedMetadata: () => Promise<string>\n  isBuildTimePrerendering: boolean\n  buildId: string\n}\n\nexport async function continueStaticPrerender(\n  prerenderStream: ReadableStream<Uint8Array>,\n  {\n    inlinedDataStream,\n    getServerInsertedHTML,\n    getServerInsertedMetadata,\n    isBuildTimePrerendering,\n    buildId,\n  }: ContinueStaticPrerenderOptions\n) {\n  return (\n    prerenderStream\n      // Buffer everything to avoid flushing too frequently\n      .pipeThrough(createBufferedTransformStream())\n      // Add build id comment to start of the HTML document (in export mode)\n      .pipeThrough(\n        createPrefetchCommentStream(isBuildTimePrerendering, buildId)\n      )\n      // Insert generated tags to head\n      .pipeThrough(createHeadInsertionTransformStream(getServerInsertedHTML))\n      // Transform metadata\n      .pipeThrough(createMetadataTransformStream(getServerInsertedMetadata))\n      // Insert the inlined data (Flight data, form state, etc.) stream into the HTML\n      .pipeThrough(\n        createFlightDataInjectionTransformStream(inlinedDataStream, true)\n      )\n      // Close tags should always be deferred to the end\n      .pipeThrough(createMoveSuffixStream())\n  )\n}\n\nexport async function continueStaticFallbackPrerender(\n  prerenderStream: ReadableStream<Uint8Array>,\n  {\n    inlinedDataStream,\n    getServerInsertedHTML,\n    getServerInsertedMetadata,\n    isBuildTimePrerendering,\n    buildId,\n  }: ContinueStaticPrerenderOptions\n) {\n  // Same as `continueStaticPrerender`, but also inserts an additional script\n  // to instruct the client to start fetching the hydration data as early\n  // as possible.\n  return (\n    prerenderStream\n      // Buffer everything to avoid flushing too frequently\n      .pipeThrough(createBufferedTransformStream())\n      // Add build id comment to start of the HTML document (in export mode)\n      .pipeThrough(\n        createPrefetchCommentStream(isBuildTimePrerendering, buildId)\n      )\n      // Insert generated tags to head\n      .pipeThrough(createHeadInsertionTransformStream(getServerInsertedHTML))\n      // Insert the client resume script into the head\n      .pipeThrough(createClientResumeScriptInsertionTransformStream())\n      // Transform metadata\n      .pipeThrough(createMetadataTransformStream(getServerInsertedMetadata))\n      // Insert the inlined data (Flight data, form state, etc.) stream into the HTML\n      .pipeThrough(\n        createFlightDataInjectionTransformStream(inlinedDataStream, true)\n      )\n      // Close tags should always be deferred to the end\n      .pipeThrough(createMoveSuffixStream())\n  )\n}\n\ntype ContinueResumeOptions = {\n  inlinedDataStream: ReadableStream<Uint8Array>\n  getServerInsertedHTML: () => Promise<string>\n  getServerInsertedMetadata: () => Promise<string>\n  delayDataUntilFirstHtmlChunk: boolean\n}\n\nexport async function continueDynamicHTMLResume(\n  renderStream: ReadableStream<Uint8Array>,\n  {\n    delayDataUntilFirstHtmlChunk,\n    inlinedDataStream,\n    getServerInsertedHTML,\n    getServerInsertedMetadata,\n  }: ContinueResumeOptions\n) {\n  return (\n    renderStream\n      // Buffer everything to avoid flushing too frequently\n      .pipeThrough(createBufferedTransformStream())\n      // Insert generated tags to head\n      .pipeThrough(createHeadInsertionTransformStream(getServerInsertedHTML))\n      // Transform metadata\n      .pipeThrough(createMetadataTransformStream(getServerInsertedMetadata))\n      // Insert the inlined data (Flight data, form state, etc.) stream into the HTML\n      .pipeThrough(\n        createFlightDataInjectionTransformStream(\n          inlinedDataStream,\n          delayDataUntilFirstHtmlChunk\n        )\n      )\n      // Close tags should always be deferred to the end\n      .pipeThrough(createMoveSuffixStream())\n  )\n}\n\nexport function createDocumentClosingStream(): ReadableStream<Uint8Array> {\n  return streamFromString(CLOSE_TAG)\n}\n","export class InvariantError extends Error {\n  constructor(message: string, options?: ErrorOptions) {\n    super(\n      `Invariant: ${message.endsWith('.') ? message : message + '.'} This is a bug in Next.js.`,\n      options\n    )\n    this.name = 'InvariantError'\n  }\n}\n","/**\n * For a given page path, this function ensures that there is a leading slash.\n * If there is not a leading slash, one is added, otherwise it is noop.\n */\nexport function ensureLeadingSlash(path: string) {\n  return path.startsWith('/') ? path : `/${path}`\n}\n","import type { FlightRouterState, Segment } from './app-router-types'\n\nexport function getSegmentValue(segment: Segment) {\n  return Array.isArray(segment) ? segment[1] : segment\n}\n\nexport function isGroupSegment(segment: string) {\n  // Use array[0] for performant purpose\n  return segment[0] === '(' && segment.endsWith(')')\n}\n\nexport function isParallelRouteSegment(segment: string) {\n  return segment.startsWith('@') && segment !== '@children'\n}\n\nexport function addSearchParamsIfPageSegment(\n  segment: Segment,\n  searchParams: Record<string, string | string[] | undefined>\n) {\n  const isPageSegment = segment.includes(PAGE_SEGMENT_KEY)\n\n  if (isPageSegment) {\n    const stringifiedQuery = JSON.stringify(searchParams)\n    return stringifiedQuery !== '{}'\n      ? PAGE_SEGMENT_KEY + '?' + stringifiedQuery\n      : PAGE_SEGMENT_KEY\n  }\n\n  return segment\n}\n\nexport function computeSelectedLayoutSegment(\n  segments: string[] | null,\n  parallelRouteKey: string\n): string | null {\n  if (!segments || segments.length === 0) {\n    return null\n  }\n\n  // For 'children', use first segment; for other parallel routes, use last segment\n  const rawSegment =\n    parallelRouteKey === 'children'\n      ? segments[0]\n      : segments[segments.length - 1]\n\n  // If the default slot is showing, return null since it's not technically \"selected\" (it's a fallback)\n  // Returning an internal value like `__DEFAULT__` would be confusing\n  return rawSegment === DEFAULT_SEGMENT_KEY ? null : rawSegment\n}\n\n/** Get the canonical parameters from the current level to the leaf node. */\nexport function getSelectedLayoutSegmentPath(\n  tree: FlightRouterState,\n  parallelRouteKey: string,\n  first = true,\n  segmentPath: string[] = []\n): string[] {\n  let node: FlightRouterState\n  if (first) {\n    // Use the provided parallel route key on the first parallel route\n    node = tree[1][parallelRouteKey]\n  } else {\n    // After first parallel route prefer children, if there's no children pick the first parallel route.\n    const parallelRoutes = tree[1]\n    node = parallelRoutes.children ?? Object.values(parallelRoutes)[0]\n  }\n\n  if (!node) return segmentPath\n  const segment = node[0]\n\n  let segmentValue = getSegmentValue(segment)\n\n  if (!segmentValue || segmentValue.startsWith(PAGE_SEGMENT_KEY)) {\n    return segmentPath\n  }\n\n  segmentPath.push(segmentValue)\n\n  return getSelectedLayoutSegmentPath(\n    node,\n    parallelRouteKey,\n    false,\n    segmentPath\n  )\n}\n\nexport const PAGE_SEGMENT_KEY = '__PAGE__'\nexport const DEFAULT_SEGMENT_KEY = '__DEFAULT__'\n","import { ensureLeadingSlash } from '../../page-path/ensure-leading-slash'\nimport { isGroupSegment } from '../../segment'\n\n/**\n * Normalizes an app route so it represents the actual request path. Essentially\n * performing the following transformations:\n *\n * - `/(dashboard)/user/[id]/page` to `/user/[id]`\n * - `/(dashboard)/account/page` to `/account`\n * - `/user/[id]/page` to `/user/[id]`\n * - `/account/page` to `/account`\n * - `/page` to `/`\n * - `/(dashboard)/user/[id]/route` to `/user/[id]`\n * - `/(dashboard)/account/route` to `/account`\n * - `/user/[id]/route` to `/user/[id]`\n * - `/account/route` to `/account`\n * - `/route` to `/`\n * - `/` to `/`\n *\n * @param route the app route to normalize\n * @returns the normalized pathname\n */\nexport function normalizeAppPath(route: string) {\n  return ensureLeadingSlash(\n    route.split('/').reduce((pathname, segment, index, segments) => {\n      // Empty segments are ignored.\n      if (!segment) {\n        return pathname\n      }\n\n      // Groups are ignored.\n      if (isGroupSegment(segment)) {\n        return pathname\n      }\n\n      // Parallel segments are ignored.\n      if (segment[0] === '@') {\n        return pathname\n      }\n\n      // The last segment (if it's a leaf) should be ignored.\n      if (\n        (segment === 'page' || segment === 'route') &&\n        index === segments.length - 1\n      ) {\n        return pathname\n      }\n\n      return `${pathname}/${segment}`\n    }, '')\n  )\n}\n\n/**\n * Strips the `.rsc` extension if it's in the pathname.\n * Since this function is used on full urls it checks `?` for searchParams handling.\n */\nexport function normalizeRscURL(url: string) {\n  return url.replace(\n    /\\.rsc($|\\?)/,\n    // $1 ensures `?` is preserved\n    '$1'\n  )\n}\n","import type { ActionManifest } from '../../build/webpack/plugins/flight-client-entry-plugin'\nimport type {\n  ClientReferenceManifest,\n  ClientReferenceManifestForRsc,\n} from '../../build/webpack/plugins/flight-manifest-plugin'\nimport type { DeepReadonly } from '../../shared/lib/deep-readonly'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'\nimport { workAsyncStorage } from './work-async-storage.external'\n\nlet __next_loaded_action_key: CryptoKey\n\nexport function arrayBufferToString(\n  buffer: ArrayBuffer | Uint8Array<ArrayBufferLike>\n) {\n  const bytes = new Uint8Array(buffer)\n  const len = bytes.byteLength\n\n  // @anonrig: V8 has a limit of 65535 arguments in a function.\n  // For len < 65535, this is faster.\n  // https://github.com/vercel/next.js/pull/56377#pullrequestreview-1656181623\n  if (len < 65535) {\n    return String.fromCharCode.apply(null, bytes as unknown as number[])\n  }\n\n  let binary = ''\n  for (let i = 0; i < len; i++) {\n    binary += String.fromCharCode(bytes[i])\n  }\n  return binary\n}\n\nexport function stringToUint8Array(binary: string) {\n  const len = binary.length\n  const arr = new Uint8Array(len)\n\n  for (let i = 0; i < len; i++) {\n    arr[i] = binary.charCodeAt(i)\n  }\n\n  return arr\n}\n\nexport function encrypt(\n  key: CryptoKey,\n  iv: Uint8Array<ArrayBuffer>,\n  data: Uint8Array<ArrayBuffer>\n) {\n  return crypto.subtle.encrypt(\n    {\n      name: 'AES-GCM',\n      iv,\n    },\n    key,\n    data\n  )\n}\n\nexport function decrypt(\n  key: CryptoKey,\n  iv: Uint8Array<ArrayBuffer>,\n  data: Uint8Array<ArrayBuffer>\n) {\n  return crypto.subtle.decrypt(\n    {\n      name: 'AES-GCM',\n      iv,\n    },\n    key,\n    data\n  )\n}\n\n// This is a global singleton that is used to encode/decode the action bound args from\n// the closure. This can't be using a AsyncLocalStorage as it might happen on the module\n// level. Since the client reference manifest won't be mutated, let's use a global singleton\n// to keep it.\nconst SERVER_ACTION_MANIFESTS_SINGLETON = Symbol.for(\n  'next.server.action-manifests'\n)\n\nexport function setReferenceManifestsSingleton({\n  page,\n  clientReferenceManifest,\n  serverActionsManifest,\n  serverModuleMap,\n}: {\n  page: string\n  clientReferenceManifest: DeepReadonly<ClientReferenceManifest>\n  serverActionsManifest: DeepReadonly<ActionManifest>\n  serverModuleMap: {\n    [id: string]: {\n      id: string\n      chunks: string[]\n      name: string\n    }\n  }\n}) {\n  // @ts-expect-error\n  const clientReferenceManifestsPerPage = globalThis[\n    SERVER_ACTION_MANIFESTS_SINGLETON\n  ]?.clientReferenceManifestsPerPage as\n    | undefined\n    | DeepReadonly<Record<string, ClientReferenceManifest>>\n\n  // @ts-expect-error\n  globalThis[SERVER_ACTION_MANIFESTS_SINGLETON] = {\n    clientReferenceManifestsPerPage: {\n      ...clientReferenceManifestsPerPage,\n      [normalizeAppPath(page)]: clientReferenceManifest,\n    },\n    serverActionsManifest,\n    serverModuleMap,\n  }\n}\n\nexport function getServerModuleMap() {\n  const serverActionsManifestSingleton = (globalThis as any)[\n    SERVER_ACTION_MANIFESTS_SINGLETON\n  ] as {\n    serverModuleMap: {\n      [id: string]: {\n        id: string\n        chunks: string[]\n        name: string\n      }\n    }\n  }\n\n  if (!serverActionsManifestSingleton) {\n    throw new InvariantError('Missing manifest for Server Actions.')\n  }\n\n  return serverActionsManifestSingleton.serverModuleMap\n}\n\nexport function getClientReferenceManifestForRsc(): DeepReadonly<ClientReferenceManifestForRsc> {\n  const serverActionsManifestSingleton = (globalThis as any)[\n    SERVER_ACTION_MANIFESTS_SINGLETON\n  ] as {\n    clientReferenceManifestsPerPage: DeepReadonly<\n      Record<string, ClientReferenceManifest>\n    >\n  }\n\n  if (!serverActionsManifestSingleton) {\n    throw new InvariantError('Missing manifest for Server Actions.')\n  }\n\n  const { clientReferenceManifestsPerPage } = serverActionsManifestSingleton\n  const workStore = workAsyncStorage.getStore()\n\n  if (!workStore) {\n    // If there's no work store defined, we can assume that a client reference\n    // manifest is needed during module evaluation, e.g. to create a server\n    // action using a higher-order function. This might also use client\n    // components which need to be serialized by Flight, and therefore client\n    // references need to be resolvable. To make this work, we're returning a\n    // merged manifest across all pages. This is fine as long as the module IDs\n    // are not page specific, which they are not for Webpack. TODO: Fix this in\n    // Turbopack.\n    return mergeClientReferenceManifests(clientReferenceManifestsPerPage)\n  }\n\n  const clientReferenceManifest =\n    clientReferenceManifestsPerPage[workStore.route]\n\n  if (!clientReferenceManifest) {\n    throw new InvariantError(\n      `Missing Client Reference Manifest for ${workStore.route}.`\n    )\n  }\n\n  return clientReferenceManifest\n}\n\nexport async function getActionEncryptionKey() {\n  if (__next_loaded_action_key) {\n    return __next_loaded_action_key\n  }\n\n  const serverActionsManifestSingleton = (globalThis as any)[\n    SERVER_ACTION_MANIFESTS_SINGLETON\n  ] as {\n    serverActionsManifest: DeepReadonly<ActionManifest>\n  }\n\n  if (!serverActionsManifestSingleton) {\n    throw new InvariantError('Missing manifest for Server Actions.')\n  }\n\n  const rawKey =\n    process.env.NEXT_SERVER_ACTIONS_ENCRYPTION_KEY ||\n    serverActionsManifestSingleton.serverActionsManifest.encryptionKey\n\n  if (rawKey === undefined) {\n    throw new InvariantError('Missing encryption key for Server Actions')\n  }\n\n  __next_loaded_action_key = await crypto.subtle.importKey(\n    'raw',\n    stringToUint8Array(atob(rawKey)),\n    'AES-GCM',\n    true,\n    ['encrypt', 'decrypt']\n  )\n\n  return __next_loaded_action_key\n}\n\nfunction mergeClientReferenceManifests(\n  clientReferenceManifestsPerPage: DeepReadonly<\n    Record<string, ClientReferenceManifest>\n  >\n): ClientReferenceManifestForRsc {\n  const clientReferenceManifests = Object.values(\n    clientReferenceManifestsPerPage as Record<string, ClientReferenceManifest>\n  )\n\n  const mergedClientReferenceManifest: ClientReferenceManifestForRsc = {\n    clientModules: {},\n    edgeRscModuleMapping: {},\n    rscModuleMapping: {},\n  }\n\n  for (const clientReferenceManifest of clientReferenceManifests) {\n    mergedClientReferenceManifest.clientModules = {\n      ...mergedClientReferenceManifest.clientModules,\n      ...clientReferenceManifest.clientModules,\n    }\n    mergedClientReferenceManifest.edgeRscModuleMapping = {\n      ...mergedClientReferenceManifest.edgeRscModuleMapping,\n      ...clientReferenceManifest.edgeRscModuleMapping,\n    }\n    mergedClientReferenceManifest.rscModuleMapping = {\n      ...mergedClientReferenceManifest.rscModuleMapping,\n      ...clientReferenceManifest.rscModuleMapping,\n    }\n  }\n\n  return mergedClientReferenceManifest\n}\n","const DYNAMIC_ERROR_CODE = 'DYNAMIC_SERVER_USAGE'\n\nexport class DynamicServerError extends Error {\n  digest: typeof DYNAMIC_ERROR_CODE = DYNAMIC_ERROR_CODE\n\n  constructor(public readonly description: string) {\n    super(`Dynamic server usage: ${description}`)\n  }\n}\n\nexport function isDynamicServerError(err: unknown): err is DynamicServerError {\n  if (\n    typeof err !== 'object' ||\n    err === null ||\n    !('digest' in err) ||\n    typeof err.digest !== 'string'\n  ) {\n    return false\n  }\n\n  return err.digest === DYNAMIC_ERROR_CODE\n}\n","const NEXT_STATIC_GEN_BAILOUT = 'NEXT_STATIC_GEN_BAILOUT'\n\nexport class StaticGenBailoutError extends Error {\n  public readonly code = NEXT_STATIC_GEN_BAILOUT\n}\n\nexport function isStaticGenBailoutError(\n  error: unknown\n): error is StaticGenBailoutError {\n  if (typeof error !== 'object' || error === null || !('code' in error)) {\n    return false\n  }\n\n  return error.code === NEXT_STATIC_GEN_BAILOUT\n}\n","import type { NonStaticRenderStage } from './app-render/staged-rendering'\nimport type { RequestStore } from './app-render/work-unit-async-storage.external'\n\nexport function isHangingPromiseRejectionError(\n  err: unknown\n): err is HangingPromiseRejectionError {\n  if (typeof err !== 'object' || err === null || !('digest' in err)) {\n    return false\n  }\n\n  return err.digest === HANGING_PROMISE_REJECTION\n}\n\nconst HANGING_PROMISE_REJECTION = 'HANGING_PROMISE_REJECTION'\n\nclass HangingPromiseRejectionError extends Error {\n  public readonly digest = HANGING_PROMISE_REJECTION\n\n  constructor(\n    public readonly route: string,\n    public readonly expression: string\n  ) {\n    super(\n      `During prerendering, ${expression} rejects when the prerender is complete. Typically these errors are handled by React but if you move ${expression} to a different context by using \\`setTimeout\\`, \\`after\\`, or similar functions you may observe this error and you should handle it in that context. This occurred at route \"${route}\".`\n    )\n  }\n}\n\ntype AbortListeners = Array<(err: unknown) => void>\nconst abortListenersBySignal = new WeakMap<AbortSignal, AbortListeners>()\n\n/**\n * This function constructs a promise that will never resolve. This is primarily\n * useful for cacheComponents where we use promise resolution timing to determine which\n * parts of a render can be included in a prerender.\n *\n * @internal\n */\nexport function makeHangingPromise<T>(\n  signal: AbortSignal,\n  route: string,\n  expression: string\n): Promise<T> {\n  if (signal.aborted) {\n    return Promise.reject(new HangingPromiseRejectionError(route, expression))\n  } else {\n    const hangingPromise = new Promise<T>((_, reject) => {\n      const boundRejection = reject.bind(\n        null,\n        new HangingPromiseRejectionError(route, expression)\n      )\n      let currentListeners = abortListenersBySignal.get(signal)\n      if (currentListeners) {\n        currentListeners.push(boundRejection)\n      } else {\n        const listeners = [boundRejection]\n        abortListenersBySignal.set(signal, listeners)\n        signal.addEventListener(\n          'abort',\n          () => {\n            for (let i = 0; i < listeners.length; i++) {\n              listeners[i]()\n            }\n          },\n          { once: true }\n        )\n      }\n    })\n    // We are fine if no one actually awaits this promise. We shouldn't consider this an unhandled rejection so\n    // we attach a noop catch handler here to suppress this warning. If you actually await somewhere or construct\n    // your own promise out of it you'll need to ensure you handle the error when it rejects.\n    hangingPromise.catch(ignoreReject)\n    return hangingPromise\n  }\n}\n\nfunction ignoreReject() {}\n\nexport function makeDevtoolsIOAwarePromise<T>(\n  underlying: T,\n  requestStore: RequestStore,\n  stage: NonStaticRenderStage\n): Promise<T> {\n  if (requestStore.stagedRendering) {\n    // We resolve each stage in a timeout, so React DevTools will pick this up as IO.\n    return requestStore.stagedRendering.delayUntilStage(\n      stage,\n      undefined,\n      underlying\n    )\n  }\n  // in React DevTools if we resolve in a setTimeout we will observe\n  // the promise resolution as something that can suspend a boundary or root.\n  return new Promise<T>((resolve) => {\n    // Must use setTimeout to be considered IO React DevTools. setImmediate will not work.\n    setTimeout(() => {\n      resolve(underlying)\n    }, 0)\n  })\n}\n","export const METADATA_BOUNDARY_NAME = '__next_metadata_boundary__'\nexport const VIEWPORT_BOUNDARY_NAME = '__next_viewport_boundary__'\nexport const OUTLET_BOUNDARY_NAME = '__next_outlet_boundary__'\nexport const ROOT_LAYOUT_BOUNDARY_NAME = '__next_root_layout_boundary__'\n","// This has to be a shared module which is shared between client component error boundary and dynamic component\nconst BAILOUT_TO_CSR = 'BAILOUT_TO_CLIENT_SIDE_RENDERING'\n\n/** An error that should be thrown when we want to bail out to client-side rendering. */\nexport class BailoutToCSRError extends Error {\n  public readonly digest = BAILOUT_TO_CSR\n\n  constructor(public readonly reason: string) {\n    super(`Bail out to client-side rendering: ${reason}`)\n  }\n}\n\n/** Checks if a passed argument is an error that is thrown if we want to bail out to client-side rendering. */\nexport function isBailoutToCSRError(err: unknown): err is BailoutToCSRError {\n  if (typeof err !== 'object' || err === null || !('digest' in err)) {\n    return false\n  }\n\n  return err.digest === BAILOUT_TO_CSR\n}\n","export function createPromiseWithResolvers<T>(): PromiseWithResolvers<T> {\n  // Shim of Stage 4 Promise.withResolvers proposal\n  let resolve: (value: T | PromiseLike<T>) => void\n  let reject: (reason: any) => void\n  const promise = new Promise<T>((res, rej) => {\n    resolve = res\n    reject = rej\n  })\n  return { resolve: resolve!, reject: reject!, promise }\n}\n","import { InvariantError } from '../../shared/lib/invariant-error'\nimport { createPromiseWithResolvers } from '../../shared/lib/promise-with-resolvers'\n\nexport enum RenderStage {\n  Static = 1,\n  Runtime = 2,\n  Dynamic = 3,\n}\n\nexport type NonStaticRenderStage = RenderStage.Runtime | RenderStage.Dynamic\n\nexport class StagedRenderingController {\n  currentStage: RenderStage = RenderStage.Static\n\n  private runtimeStagePromise = createPromiseWithResolvers<void>()\n  private dynamicStagePromise = createPromiseWithResolvers<void>()\n\n  constructor(private abortSignal: AbortSignal | null = null) {\n    if (abortSignal) {\n      abortSignal.addEventListener(\n        'abort',\n        () => {\n          const { reason } = abortSignal\n          if (this.currentStage < RenderStage.Runtime) {\n            this.runtimeStagePromise.promise.catch(ignoreReject) // avoid unhandled rejections\n            this.runtimeStagePromise.reject(reason)\n          }\n          if (this.currentStage < RenderStage.Dynamic) {\n            this.dynamicStagePromise.promise.catch(ignoreReject) // avoid unhandled rejections\n            this.dynamicStagePromise.reject(reason)\n          }\n        },\n        { once: true }\n      )\n    }\n  }\n\n  advanceStage(stage: NonStaticRenderStage) {\n    // If we're already at the target stage or beyond, do nothing.\n    // (this can happen e.g. if sync IO advanced us to the dynamic stage)\n    if (this.currentStage >= stage) {\n      return\n    }\n    this.currentStage = stage\n    // Note that we might be going directly from Static to Dynamic,\n    // so we need to resolve the runtime stage as well.\n    if (stage >= RenderStage.Runtime) {\n      this.runtimeStagePromise.resolve()\n    }\n    if (stage >= RenderStage.Dynamic) {\n      this.dynamicStagePromise.resolve()\n    }\n  }\n\n  private getStagePromise(stage: NonStaticRenderStage): Promise<void> {\n    switch (stage) {\n      case RenderStage.Runtime: {\n        return this.runtimeStagePromise.promise\n      }\n      case RenderStage.Dynamic: {\n        return this.dynamicStagePromise.promise\n      }\n      default: {\n        stage satisfies never\n        throw new InvariantError(`Invalid render stage: ${stage}`)\n      }\n    }\n  }\n\n  waitForStage(stage: NonStaticRenderStage) {\n    return this.getStagePromise(stage)\n  }\n\n  delayUntilStage<T>(\n    stage: NonStaticRenderStage,\n    displayName: string | undefined,\n    resolvedValue: T\n  ) {\n    const ioTriggerPromise = this.getStagePromise(stage)\n\n    const promise = makeDevtoolsIOPromiseFromIOTrigger(\n      ioTriggerPromise,\n      displayName,\n      resolvedValue\n    )\n\n    // Analogously to `makeHangingPromise`, we might reject this promise if the signal is invoked.\n    // (e.g. in the case where we don't want want the render to proceed to the dynamic stage and abort it).\n    // We shouldn't consider this an unhandled rejection, so we attach a noop catch handler here to suppress this warning.\n    if (this.abortSignal) {\n      promise.catch(ignoreReject)\n    }\n    return promise\n  }\n}\n\nfunction ignoreReject() {}\n\n// TODO(restart-on-cache-miss): the layering of `delayUntilStage`,\n// `makeDevtoolsIOPromiseFromIOTrigger` and and `makeDevtoolsIOAwarePromise`\n// is confusing, we should clean it up.\nfunction makeDevtoolsIOPromiseFromIOTrigger<T>(\n  ioTrigger: Promise<any>,\n  displayName: string | undefined,\n  resolvedValue: T\n): Promise<T> {\n  // If we create a `new Promise` and give it a displayName\n  // (with no userspace code above us in the stack)\n  // React Devtools will use it as the IO cause when determining \"suspended by\".\n  // In particular, it should shadow any inner IO that resolved/rejected the promise\n  // (in case of staged rendering, this will be the `setTimeout` that triggers the relevant stage)\n  const promise = new Promise<T>((resolve, reject) => {\n    ioTrigger.then(resolve.bind(null, resolvedValue), reject)\n  })\n  if (displayName !== undefined) {\n    // @ts-expect-error\n    promise.displayName = displayName\n  }\n  return promise\n}\n","/**\n * The functions provided by this module are used to communicate certain properties\n * about the currently running code so that Next.js can make decisions on how to handle\n * the current execution in different rendering modes such as pre-rendering, resuming, and SSR.\n *\n * Today Next.js treats all code as potentially static. Certain APIs may only make sense when dynamically rendering.\n * Traditionally this meant deopting the entire render to dynamic however with PPR we can now deopt parts\n * of a React tree as dynamic while still keeping other parts static. There are really two different kinds of\n * Dynamic indications.\n *\n * The first is simply an intention to be dynamic. unstable_noStore is an example of this where\n * the currently executing code simply declares that the current scope is dynamic but if you use it\n * inside unstable_cache it can still be cached. This type of indication can be removed if we ever\n * make the default dynamic to begin with because the only way you would ever be static is inside\n * a cache scope which this indication does not affect.\n *\n * The second is an indication that a dynamic data source was read. This is a stronger form of dynamic\n * because it means that it is inappropriate to cache this at all. using a dynamic data source inside\n * unstable_cache should error. If you want to use some dynamic data inside unstable_cache you should\n * read that data outside the cache and pass it in as an argument to the cached function.\n */\n\nimport type { WorkStore } from '../app-render/work-async-storage.external'\nimport type {\n  WorkUnitStore,\n  RequestStore,\n  PrerenderStoreLegacy,\n  PrerenderStoreModern,\n  PrerenderStoreModernRuntime,\n} from '../app-render/work-unit-async-storage.external'\n\n// Once postpone is in stable we should switch to importing the postpone export directly\nimport React from 'react'\n\nimport { DynamicServerError } from '../../client/components/hooks-server-context'\nimport { StaticGenBailoutError } from '../../client/components/static-generation-bailout'\nimport {\n  getRuntimeStagePromise,\n  throwForMissingRequestStore,\n  workUnitAsyncStorage,\n} from './work-unit-async-storage.external'\nimport { workAsyncStorage } from '../app-render/work-async-storage.external'\nimport { makeHangingPromise } from '../dynamic-rendering-utils'\nimport {\n  METADATA_BOUNDARY_NAME,\n  VIEWPORT_BOUNDARY_NAME,\n  OUTLET_BOUNDARY_NAME,\n  ROOT_LAYOUT_BOUNDARY_NAME,\n} from '../../lib/framework/boundary-constants'\nimport { scheduleOnNextTick } from '../../lib/scheduler'\nimport { BailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport { RenderStage } from './staged-rendering'\n\nconst hasPostpone = typeof React.unstable_postpone === 'function'\n\nexport type DynamicAccess = {\n  /**\n   * If debugging, this will contain the stack trace of where the dynamic access\n   * occurred. This is used to provide more information to the user about why\n   * their page is being rendered dynamically.\n   */\n  stack?: string\n\n  /**\n   * The expression that was accessed dynamically.\n   */\n  expression: string\n}\n\n// Stores dynamic reasons used during an RSC render.\nexport type DynamicTrackingState = {\n  /**\n   * When true, stack information will also be tracked during dynamic access.\n   */\n  readonly isDebugDynamicAccesses: boolean | undefined\n\n  /**\n   * The dynamic accesses that occurred during the render.\n   */\n  readonly dynamicAccesses: Array<DynamicAccess>\n\n  syncDynamicErrorWithStack: null | Error\n}\n\n// Stores dynamic reasons used during an SSR render.\nexport type DynamicValidationState = {\n  hasSuspenseAboveBody: boolean\n  hasDynamicMetadata: boolean\n  hasDynamicViewport: boolean\n  hasAllowedDynamic: boolean\n  dynamicErrors: Array<Error>\n}\n\nexport function createDynamicTrackingState(\n  isDebugDynamicAccesses: boolean | undefined\n): DynamicTrackingState {\n  return {\n    isDebugDynamicAccesses,\n    dynamicAccesses: [],\n    syncDynamicErrorWithStack: null,\n  }\n}\n\nexport function createDynamicValidationState(): DynamicValidationState {\n  return {\n    hasSuspenseAboveBody: false,\n    hasDynamicMetadata: false,\n    hasDynamicViewport: false,\n    hasAllowedDynamic: false,\n    dynamicErrors: [],\n  }\n}\n\nexport function getFirstDynamicReason(\n  trackingState: DynamicTrackingState\n): undefined | string {\n  return trackingState.dynamicAccesses[0]?.expression\n}\n\n/**\n * This function communicates that the current scope should be treated as dynamic.\n *\n * In most cases this function is a no-op but if called during\n * a PPR prerender it will postpone the current sub-tree and calling\n * it during a normal prerender will cause the entire prerender to abort\n */\nexport function markCurrentScopeAsDynamic(\n  store: WorkStore,\n  workUnitStore: undefined | Exclude<WorkUnitStore, PrerenderStoreModern>,\n  expression: string\n): void {\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'cache':\n      case 'unstable-cache':\n        // Inside cache scopes, marking a scope as dynamic has no effect,\n        // because the outer cache scope creates a cache boundary. This is\n        // subtly different from reading a dynamic data source, which is\n        // forbidden inside a cache scope.\n        return\n      case 'private-cache':\n        // A private cache scope is already dynamic by definition.\n        return\n      case 'prerender-legacy':\n      case 'prerender-ppr':\n      case 'request':\n        break\n      default:\n        workUnitStore satisfies never\n    }\n  }\n\n  // If we're forcing dynamic rendering or we're forcing static rendering, we\n  // don't need to do anything here because the entire page is already dynamic\n  // or it's static and it should not throw or postpone here.\n  if (store.forceDynamic || store.forceStatic) return\n\n  if (store.dynamicShouldError) {\n    throw new StaticGenBailoutError(\n      `Route ${store.route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n    )\n  }\n\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender-ppr':\n        return postponeWithTracking(\n          store.route,\n          expression,\n          workUnitStore.dynamicTracking\n        )\n      case 'prerender-legacy':\n        workUnitStore.revalidate = 0\n\n        // We aren't prerendering, but we are generating a static page. We need\n        // to bail out of static generation.\n        const err = new DynamicServerError(\n          `Route ${store.route} couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`\n        )\n        store.dynamicUsageDescription = expression\n        store.dynamicUsageStack = err.stack\n\n        throw err\n      case 'request':\n        if (process.env.NODE_ENV !== 'production') {\n          workUnitStore.usedDynamic = true\n        }\n        break\n      default:\n        workUnitStore satisfies never\n    }\n  }\n}\n\n/**\n * This function is meant to be used when prerendering without cacheComponents or PPR.\n * When called during a build it will cause Next.js to consider the route as dynamic.\n *\n * @internal\n */\nexport function throwToInterruptStaticGeneration(\n  expression: string,\n  store: WorkStore,\n  prerenderStore: PrerenderStoreLegacy\n): never {\n  // We aren't prerendering but we are generating a static page. We need to bail out of static generation\n  const err = new DynamicServerError(\n    `Route ${store.route} couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`\n  )\n\n  prerenderStore.revalidate = 0\n\n  store.dynamicUsageDescription = expression\n  store.dynamicUsageStack = err.stack\n\n  throw err\n}\n\n/**\n * This function should be used to track whether something dynamic happened even when\n * we are in a dynamic render. This is useful for Dev where all renders are dynamic but\n * we still track whether dynamic APIs were accessed for helpful messaging\n *\n * @internal\n */\nexport function trackDynamicDataInDynamicRender(workUnitStore: WorkUnitStore) {\n  switch (workUnitStore.type) {\n    case 'cache':\n    case 'unstable-cache':\n      // Inside cache scopes, marking a scope as dynamic has no effect,\n      // because the outer cache scope creates a cache boundary. This is\n      // subtly different from reading a dynamic data source, which is\n      // forbidden inside a cache scope.\n      return\n    case 'private-cache':\n      // A private cache scope is already dynamic by definition.\n      return\n    case 'prerender':\n    case 'prerender-runtime':\n    case 'prerender-legacy':\n    case 'prerender-ppr':\n    case 'prerender-client':\n      break\n    case 'request':\n      if (process.env.NODE_ENV !== 'production') {\n        workUnitStore.usedDynamic = true\n      }\n      break\n    default:\n      workUnitStore satisfies never\n  }\n}\n\nfunction abortOnSynchronousDynamicDataAccess(\n  route: string,\n  expression: string,\n  prerenderStore: PrerenderStoreModern\n): void {\n  const reason = `Route ${route} needs to bail out of prerendering at this point because it used ${expression}.`\n\n  const error = createPrerenderInterruptedError(reason)\n\n  prerenderStore.controller.abort(error)\n\n  const dynamicTracking = prerenderStore.dynamicTracking\n  if (dynamicTracking) {\n    dynamicTracking.dynamicAccesses.push({\n      // When we aren't debugging, we don't need to create another error for the\n      // stack trace.\n      stack: dynamicTracking.isDebugDynamicAccesses\n        ? new Error().stack\n        : undefined,\n      expression,\n    })\n  }\n}\n\nexport function abortOnSynchronousPlatformIOAccess(\n  route: string,\n  expression: string,\n  errorWithStack: Error,\n  prerenderStore: PrerenderStoreModern\n): void {\n  const dynamicTracking = prerenderStore.dynamicTracking\n  abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore)\n  // It is important that we set this tracking value after aborting. Aborts are executed\n  // synchronously except for the case where you abort during render itself. By setting this\n  // value late we can use it to determine if any of the aborted tasks are the task that\n  // called the sync IO expression in the first place.\n  if (dynamicTracking) {\n    if (dynamicTracking.syncDynamicErrorWithStack === null) {\n      dynamicTracking.syncDynamicErrorWithStack = errorWithStack\n    }\n  }\n}\n\nexport function trackSynchronousPlatformIOAccessInDev(\n  requestStore: RequestStore\n): void {\n  // We don't actually have a controller to abort but we do the semantic equivalent by\n  // advancing the request store out of the prerender stage\n  if (requestStore.stagedRendering) {\n    // TODO: error for sync IO in the runtime stage\n    // (which is not currently covered by the validation render in `spawnDynamicValidationInDev`)\n    requestStore.stagedRendering.advanceStage(RenderStage.Dynamic)\n  }\n}\n\n/**\n * use this function when prerendering with cacheComponents. If we are doing a\n * prospective prerender we don't actually abort because we want to discover\n * all caches for the shell. If this is the actual prerender we do abort.\n *\n * This function accepts a prerenderStore but the caller should ensure we're\n * actually running in cacheComponents mode.\n *\n * @internal\n */\nexport function abortAndThrowOnSynchronousRequestDataAccess(\n  route: string,\n  expression: string,\n  errorWithStack: Error,\n  prerenderStore: PrerenderStoreModern\n): never {\n  const prerenderSignal = prerenderStore.controller.signal\n  if (prerenderSignal.aborted === false) {\n    // TODO it would be better to move this aborted check into the callsite so we can avoid making\n    // the error object when it isn't relevant to the aborting of the prerender however\n    // since we need the throw semantics regardless of whether we abort it is easier to land\n    // this way. See how this was handled with `abortOnSynchronousPlatformIOAccess` for a closer\n    // to ideal implementation\n    abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore)\n    // It is important that we set this tracking value after aborting. Aborts are executed\n    // synchronously except for the case where you abort during render itself. By setting this\n    // value late we can use it to determine if any of the aborted tasks are the task that\n    // called the sync IO expression in the first place.\n    const dynamicTracking = prerenderStore.dynamicTracking\n    if (dynamicTracking) {\n      if (dynamicTracking.syncDynamicErrorWithStack === null) {\n        dynamicTracking.syncDynamicErrorWithStack = errorWithStack\n      }\n    }\n  }\n  throw createPrerenderInterruptedError(\n    `Route ${route} needs to bail out of prerendering at this point because it used ${expression}.`\n  )\n}\n\n/**\n * This component will call `React.postpone` that throws the postponed error.\n */\ntype PostponeProps = {\n  reason: string\n  route: string\n}\nexport function Postpone({ reason, route }: PostponeProps): never {\n  const prerenderStore = workUnitAsyncStorage.getStore()\n  const dynamicTracking =\n    prerenderStore && prerenderStore.type === 'prerender-ppr'\n      ? prerenderStore.dynamicTracking\n      : null\n  postponeWithTracking(route, reason, dynamicTracking)\n}\n\nexport function postponeWithTracking(\n  route: string,\n  expression: string,\n  dynamicTracking: null | DynamicTrackingState\n): never {\n  assertPostpone()\n  if (dynamicTracking) {\n    dynamicTracking.dynamicAccesses.push({\n      // When we aren't debugging, we don't need to create another error for the\n      // stack trace.\n      stack: dynamicTracking.isDebugDynamicAccesses\n        ? new Error().stack\n        : undefined,\n      expression,\n    })\n  }\n\n  React.unstable_postpone(createPostponeReason(route, expression))\n}\n\nfunction createPostponeReason(route: string, expression: string) {\n  return (\n    `Route ${route} needs to bail out of prerendering at this point because it used ${expression}. ` +\n    `React throws this special object to indicate where. It should not be caught by ` +\n    `your own try/catch. Learn more: https://nextjs.org/docs/messages/ppr-caught-error`\n  )\n}\n\nexport function isDynamicPostpone(err: unknown) {\n  if (\n    typeof err === 'object' &&\n    err !== null &&\n    typeof (err as any).message === 'string'\n  ) {\n    return isDynamicPostponeReason((err as any).message)\n  }\n  return false\n}\n\nfunction isDynamicPostponeReason(reason: string) {\n  return (\n    reason.includes(\n      'needs to bail out of prerendering at this point because it used'\n    ) &&\n    reason.includes(\n      'Learn more: https://nextjs.org/docs/messages/ppr-caught-error'\n    )\n  )\n}\n\nif (isDynamicPostponeReason(createPostponeReason('%%%', '^^^')) === false) {\n  throw new Error(\n    'Invariant: isDynamicPostpone misidentified a postpone reason. This is a bug in Next.js'\n  )\n}\n\nconst NEXT_PRERENDER_INTERRUPTED = 'NEXT_PRERENDER_INTERRUPTED'\n\nfunction createPrerenderInterruptedError(message: string): Error {\n  const error = new Error(message)\n  ;(error as any).digest = NEXT_PRERENDER_INTERRUPTED\n  return error\n}\n\ntype DigestError = Error & {\n  digest: string\n}\n\nexport function isPrerenderInterruptedError(\n  error: unknown\n): error is DigestError {\n  return (\n    typeof error === 'object' &&\n    error !== null &&\n    (error as any).digest === NEXT_PRERENDER_INTERRUPTED &&\n    'name' in error &&\n    'message' in error &&\n    error instanceof Error\n  )\n}\n\nexport function accessedDynamicData(\n  dynamicAccesses: Array<DynamicAccess>\n): boolean {\n  return dynamicAccesses.length > 0\n}\n\nexport function consumeDynamicAccess(\n  serverDynamic: DynamicTrackingState,\n  clientDynamic: DynamicTrackingState\n): DynamicTrackingState['dynamicAccesses'] {\n  // We mutate because we only call this once we are no longer writing\n  // to the dynamicTrackingState and it's more efficient than creating a new\n  // array.\n  serverDynamic.dynamicAccesses.push(...clientDynamic.dynamicAccesses)\n  return serverDynamic.dynamicAccesses\n}\n\nexport function formatDynamicAPIAccesses(\n  dynamicAccesses: Array<DynamicAccess>\n): string[] {\n  return dynamicAccesses\n    .filter(\n      (access): access is Required<DynamicAccess> =>\n        typeof access.stack === 'string' && access.stack.length > 0\n    )\n    .map(({ expression, stack }) => {\n      stack = stack\n        .split('\\n')\n        // Remove the \"Error: \" prefix from the first line of the stack trace as\n        // well as the first 4 lines of the stack trace which is the distance\n        // from the user code and the `new Error().stack` call.\n        .slice(4)\n        .filter((line) => {\n          // Exclude Next.js internals from the stack trace.\n          if (line.includes('node_modules/next/')) {\n            return false\n          }\n\n          // Exclude anonymous functions from the stack trace.\n          if (line.includes(' (<anonymous>)')) {\n            return false\n          }\n\n          // Exclude Node.js internals from the stack trace.\n          if (line.includes(' (node:')) {\n            return false\n          }\n\n          return true\n        })\n        .join('\\n')\n      return `Dynamic API Usage Debug - ${expression}:\\n${stack}`\n    })\n}\n\nfunction assertPostpone() {\n  if (!hasPostpone) {\n    throw new Error(\n      `Invariant: React.unstable_postpone is not defined. This suggests the wrong version of React was loaded. This is a bug in Next.js`\n    )\n  }\n}\n\n/**\n * This is a bit of a hack to allow us to abort a render using a Postpone instance instead of an Error which changes React's\n * abort semantics slightly.\n */\nexport function createRenderInBrowserAbortSignal(): AbortSignal {\n  const controller = new AbortController()\n  controller.abort(new BailoutToCSRError('Render in Browser'))\n  return controller.signal\n}\n\n/**\n * In a prerender, we may end up with hanging Promises as inputs due them\n * stalling on connection() or because they're loading dynamic data. In that\n * case we need to abort the encoding of arguments since they'll never complete.\n */\nexport function createHangingInputAbortSignal(\n  workUnitStore: WorkUnitStore\n): AbortSignal | undefined {\n  switch (workUnitStore.type) {\n    case 'prerender':\n    case 'prerender-runtime':\n      const controller = new AbortController()\n\n      if (workUnitStore.cacheSignal) {\n        // If we have a cacheSignal it means we're in a prospective render. If\n        // the input we're waiting on is coming from another cache, we do want\n        // to wait for it so that we can resolve this cache entry too.\n        workUnitStore.cacheSignal.inputReady().then(() => {\n          controller.abort()\n        })\n      } else {\n        // Otherwise we're in the final render and we should already have all\n        // our caches filled.\n        // If the prerender uses stages, we have wait until the runtime stage,\n        // at which point all runtime inputs will be resolved.\n        // (otherwise, a runtime prerender might consider `cookies()` hanging\n        //  even though they'd resolve in the next task.)\n        //\n        // We might still be waiting on some microtasks so we\n        // wait one tick before giving up. When we give up, we still want to\n        // render the content of this cache as deeply as we can so that we can\n        // suspend as deeply as possible in the tree or not at all if we don't\n        // end up waiting for the input.\n        const runtimeStagePromise = getRuntimeStagePromise(workUnitStore)\n        if (runtimeStagePromise) {\n          runtimeStagePromise.then(() =>\n            scheduleOnNextTick(() => controller.abort())\n          )\n        } else {\n          scheduleOnNextTick(() => controller.abort())\n        }\n      }\n\n      return controller.signal\n    case 'prerender-client':\n    case 'prerender-ppr':\n    case 'prerender-legacy':\n    case 'request':\n    case 'cache':\n    case 'private-cache':\n    case 'unstable-cache':\n      return undefined\n    default:\n      workUnitStore satisfies never\n  }\n}\n\nexport function annotateDynamicAccess(\n  expression: string,\n  prerenderStore: PrerenderStoreModern\n) {\n  const dynamicTracking = prerenderStore.dynamicTracking\n  if (dynamicTracking) {\n    dynamicTracking.dynamicAccesses.push({\n      stack: dynamicTracking.isDebugDynamicAccesses\n        ? new Error().stack\n        : undefined,\n      expression,\n    })\n  }\n}\n\nexport function useDynamicRouteParams(expression: string) {\n  const workStore = workAsyncStorage.getStore()\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (workStore && workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender-client':\n      case 'prerender': {\n        const fallbackParams = workUnitStore.fallbackRouteParams\n\n        if (fallbackParams && fallbackParams.size > 0) {\n          // We are in a prerender with cacheComponents semantics. We are going to\n          // hang here and never resolve. This will cause the currently\n          // rendering component to effectively be a dynamic hole.\n          React.use(\n            makeHangingPromise(\n              workUnitStore.renderSignal,\n              workStore.route,\n              expression\n            )\n          )\n        }\n        break\n      }\n      case 'prerender-ppr': {\n        const fallbackParams = workUnitStore.fallbackRouteParams\n        if (fallbackParams && fallbackParams.size > 0) {\n          return postponeWithTracking(\n            workStore.route,\n            expression,\n            workUnitStore.dynamicTracking\n          )\n        }\n        break\n      }\n      case 'prerender-runtime':\n        throw new InvariantError(\n          `\\`${expression}\\` was called during a runtime prerender. Next.js should be preventing ${expression} from being included in server components statically, but did not in this case.`\n        )\n      case 'cache':\n      case 'private-cache':\n        throw new InvariantError(\n          `\\`${expression}\\` was called inside a cache scope. Next.js should be preventing ${expression} from being included in server components statically, but did not in this case.`\n        )\n      case 'prerender-legacy':\n      case 'request':\n      case 'unstable-cache':\n        break\n      default:\n        workUnitStore satisfies never\n    }\n  }\n}\n\nexport function useDynamicSearchParams(expression: string) {\n  const workStore = workAsyncStorage.getStore()\n  const workUnitStore = workUnitAsyncStorage.getStore()\n\n  if (!workStore) {\n    // We assume pages router context and just return\n    return\n  }\n\n  if (!workUnitStore) {\n    throwForMissingRequestStore(expression)\n  }\n\n  switch (workUnitStore.type) {\n    case 'prerender-client': {\n      React.use(\n        makeHangingPromise(\n          workUnitStore.renderSignal,\n          workStore.route,\n          expression\n        )\n      )\n      break\n    }\n    case 'prerender-legacy':\n    case 'prerender-ppr': {\n      if (workStore.forceStatic) {\n        return\n      }\n      throw new BailoutToCSRError(expression)\n    }\n    case 'prerender':\n    case 'prerender-runtime':\n      throw new InvariantError(\n        `\\`${expression}\\` was called from a Server Component. Next.js should be preventing ${expression} from being included in server components statically, but did not in this case.`\n      )\n    case 'cache':\n    case 'unstable-cache':\n    case 'private-cache':\n      throw new InvariantError(\n        `\\`${expression}\\` was called inside a cache scope. Next.js should be preventing ${expression} from being included in server components statically, but did not in this case.`\n      )\n    case 'request':\n      return\n    default:\n      workUnitStore satisfies never\n  }\n}\n\nconst hasSuspenseRegex = /\\n\\s+at Suspense \\(<anonymous>\\)/\n\n// Common implicit body tags that React will treat as body when placed directly in html\nconst bodyAndImplicitTags =\n  'body|div|main|section|article|aside|header|footer|nav|form|p|span|h1|h2|h3|h4|h5|h6'\n\n// Detects when RootLayoutBoundary (our framework marker component) appears\n// after Suspense in the component stack, indicating the root layout is wrapped\n// within a Suspense boundary. Ensures no body/html/implicit-body components are in between.\n//\n// Example matches:\n//   at Suspense (<anonymous>)\n//   at __next_root_layout_boundary__ (<anonymous>)\n//\n// Or with other components in between (but not body/html/implicit-body):\n//   at Suspense (<anonymous>)\n//   at SomeComponent (<anonymous>)\n//   at __next_root_layout_boundary__ (<anonymous>)\nconst hasSuspenseBeforeRootLayoutWithoutBodyOrImplicitBodyRegex = new RegExp(\n  `\\\\n\\\\s+at Suspense \\\\(<anonymous>\\\\)(?:(?!\\\\n\\\\s+at (?:${bodyAndImplicitTags}) \\\\(<anonymous>\\\\))[\\\\s\\\\S])*?\\\\n\\\\s+at ${ROOT_LAYOUT_BOUNDARY_NAME} \\\\([^\\\\n]*\\\\)`\n)\n\nconst hasMetadataRegex = new RegExp(\n  `\\\\n\\\\s+at ${METADATA_BOUNDARY_NAME}[\\\\n\\\\s]`\n)\nconst hasViewportRegex = new RegExp(\n  `\\\\n\\\\s+at ${VIEWPORT_BOUNDARY_NAME}[\\\\n\\\\s]`\n)\nconst hasOutletRegex = new RegExp(`\\\\n\\\\s+at ${OUTLET_BOUNDARY_NAME}[\\\\n\\\\s]`)\n\nexport function trackAllowedDynamicAccess(\n  workStore: WorkStore,\n  componentStack: string,\n  dynamicValidation: DynamicValidationState,\n  clientDynamic: DynamicTrackingState\n) {\n  if (hasOutletRegex.test(componentStack)) {\n    // We don't need to track that this is dynamic. It is only so when something else is also dynamic.\n    return\n  } else if (hasMetadataRegex.test(componentStack)) {\n    dynamicValidation.hasDynamicMetadata = true\n    return\n  } else if (hasViewportRegex.test(componentStack)) {\n    dynamicValidation.hasDynamicViewport = true\n    return\n  } else if (\n    hasSuspenseBeforeRootLayoutWithoutBodyOrImplicitBodyRegex.test(\n      componentStack\n    )\n  ) {\n    // For Suspense within body, the prelude wouldn't be empty so it wouldn't violate the empty static shells rule.\n    // But if you have Suspense above body, the prelude is empty but we allow that because having Suspense\n    // is an explicit signal from the user that they acknowledge the empty shell and want dynamic rendering.\n    dynamicValidation.hasAllowedDynamic = true\n    dynamicValidation.hasSuspenseAboveBody = true\n    return\n  } else if (hasSuspenseRegex.test(componentStack)) {\n    // this error had a Suspense boundary above it so we don't need to report it as a source\n    // of disallowed\n    dynamicValidation.hasAllowedDynamic = true\n    return\n  } else if (clientDynamic.syncDynamicErrorWithStack) {\n    // This task was the task that called the sync error.\n    dynamicValidation.dynamicErrors.push(\n      clientDynamic.syncDynamicErrorWithStack\n    )\n    return\n  } else {\n    const message =\n      `Route \"${workStore.route}\": Uncached data was accessed outside of ` +\n      '<Suspense>. This delays the entire page from rendering, resulting in a ' +\n      'slow user experience. Learn more: ' +\n      'https://nextjs.org/docs/messages/blocking-route'\n    const error = createErrorWithComponentOrOwnerStack(message, componentStack)\n    dynamicValidation.dynamicErrors.push(error)\n    return\n  }\n}\n\n/**\n * In dev mode, we prefer using the owner stack, otherwise the provided\n * component stack is used.\n */\nfunction createErrorWithComponentOrOwnerStack(\n  message: string,\n  componentStack: string\n) {\n  const ownerStack =\n    process.env.NODE_ENV !== 'production' && React.captureOwnerStack\n      ? React.captureOwnerStack()\n      : null\n\n  const error = new Error(message)\n  error.stack = error.name + ': ' + message + (ownerStack ?? componentStack)\n  return error\n}\n\nexport enum PreludeState {\n  Full = 0,\n  Empty = 1,\n  Errored = 2,\n}\n\nexport function logDisallowedDynamicError(\n  workStore: WorkStore,\n  error: Error\n): void {\n  console.error(error)\n\n  if (!workStore.dev) {\n    if (workStore.hasReadableErrorStacks) {\n      console.error(\n        `To get a more detailed stack trace and pinpoint the issue, start the app in development mode by running \\`next dev\\`, then open \"${workStore.route}\" in your browser to investigate the error.`\n      )\n    } else {\n      console.error(`To get a more detailed stack trace and pinpoint the issue, try one of the following:\n  - Start the app in development mode by running \\`next dev\\`, then open \"${workStore.route}\" in your browser to investigate the error.\n  - Rerun the production build with \\`next build --debug-prerender\\` to generate better stack traces.`)\n    }\n  }\n}\n\nexport function throwIfDisallowedDynamic(\n  workStore: WorkStore,\n  prelude: PreludeState,\n  dynamicValidation: DynamicValidationState,\n  serverDynamic: DynamicTrackingState\n): void {\n  if (serverDynamic.syncDynamicErrorWithStack) {\n    logDisallowedDynamicError(\n      workStore,\n      serverDynamic.syncDynamicErrorWithStack\n    )\n    throw new StaticGenBailoutError()\n  }\n\n  if (prelude !== PreludeState.Full) {\n    if (dynamicValidation.hasSuspenseAboveBody) {\n      // This route has opted into allowing fully dynamic rendering\n      // by including a Suspense boundary above the body. In this case\n      // a lack of a shell is not considered disallowed so we simply return\n      return\n    }\n\n    // We didn't have any sync bailouts but there may be user code which\n    // blocked the root. We would have captured these during the prerender\n    // and can log them here and then terminate the build/validating render\n    const dynamicErrors = dynamicValidation.dynamicErrors\n    if (dynamicErrors.length > 0) {\n      for (let i = 0; i < dynamicErrors.length; i++) {\n        logDisallowedDynamicError(workStore, dynamicErrors[i])\n      }\n\n      throw new StaticGenBailoutError()\n    }\n\n    // If we got this far then the only other thing that could be blocking\n    // the root is dynamic Viewport. If this is dynamic then\n    // you need to opt into that by adding a Suspense boundary above the body\n    // to indicate your are ok with fully dynamic rendering.\n    if (dynamicValidation.hasDynamicViewport) {\n      console.error(\n        `Route \"${workStore.route}\" has a \\`generateViewport\\` that depends on Request data (\\`cookies()\\`, etc...) or uncached external data (\\`fetch(...)\\`, etc...) without explicitly allowing fully dynamic rendering. See more info here: https://nextjs.org/docs/messages/next-prerender-dynamic-viewport`\n      )\n      throw new StaticGenBailoutError()\n    }\n\n    if (prelude === PreludeState.Empty) {\n      // If we ever get this far then we messed up the tracking of invalid dynamic.\n      // We still adhere to the constraint that you must produce a shell but invite the\n      // user to report this as a bug in Next.js.\n      console.error(\n        `Route \"${workStore.route}\" did not produce a static shell and Next.js was unable to determine a reason. This is a bug in Next.js.`\n      )\n      throw new StaticGenBailoutError()\n    }\n  } else {\n    if (\n      dynamicValidation.hasAllowedDynamic === false &&\n      dynamicValidation.hasDynamicMetadata\n    ) {\n      console.error(\n        `Route \"${workStore.route}\" has a \\`generateMetadata\\` that depends on Request data (\\`cookies()\\`, etc...) or uncached external data (\\`fetch(...)\\`, etc...) when the rest of the route does not. See more info here: https://nextjs.org/docs/messages/next-prerender-dynamic-metadata`\n      )\n      throw new StaticGenBailoutError()\n    }\n  }\n}\n\nexport function delayUntilRuntimeStage<T>(\n  prerenderStore: PrerenderStoreModernRuntime,\n  result: Promise<T>\n): Promise<T> {\n  if (prerenderStore.runtimeStagePromise) {\n    return prerenderStore.runtimeStagePromise.then(() => result)\n  }\n  return result\n}\n","/* eslint-disable import/no-extraneous-dependencies */\nimport 'server-only'\n\n/* eslint-disable import/no-extraneous-dependencies */\nimport { renderToReadableStream } from 'react-server-dom-webpack/server'\n/* eslint-disable import/no-extraneous-dependencies */\nimport { createFromReadableStream } from 'react-server-dom-webpack/client'\n\nimport { streamToString } from '../stream-utils/node-web-streams-helper'\nimport {\n  arrayBufferToString,\n  decrypt,\n  encrypt,\n  getActionEncryptionKey,\n  getClientReferenceManifestForRsc,\n  getServerModuleMap,\n  stringToUint8Array,\n} from './encryption-utils'\nimport {\n  getCacheSignal,\n  getPrerenderResumeDataCache,\n  getRenderResumeDataCache,\n  workUnitAsyncStorage,\n} from './work-unit-async-storage.external'\nimport { createHangingInputAbortSignal } from './dynamic-rendering'\nimport React from 'react'\n\nconst isEdgeRuntime = process.env.NEXT_RUNTIME === 'edge'\n\nconst textEncoder = new TextEncoder()\nconst textDecoder = new TextDecoder()\n\nconst filterStackFrame =\n  process.env.NODE_ENV !== 'production'\n    ? (require('../lib/source-maps') as typeof import('../lib/source-maps'))\n        .filterStackFrameDEV\n    : undefined\nconst findSourceMapURL =\n  process.env.NODE_ENV !== 'production'\n    ? (require('../lib/source-maps') as typeof import('../lib/source-maps'))\n        .findSourceMapURLDEV\n    : undefined\n\n/**\n * Decrypt the serialized string with the action id as the salt.\n */\nasync function decodeActionBoundArg(actionId: string, arg: string) {\n  const key = await getActionEncryptionKey()\n  if (typeof key === 'undefined') {\n    throw new Error(\n      `Missing encryption key for Server Action. This is a bug in Next.js`\n    )\n  }\n\n  // Get the iv (16 bytes) and the payload from the arg.\n  const originalPayload = atob(arg)\n  const ivValue = originalPayload.slice(0, 16)\n  const payload = originalPayload.slice(16)\n\n  const decrypted = textDecoder.decode(\n    await decrypt(key, stringToUint8Array(ivValue), stringToUint8Array(payload))\n  )\n\n  if (!decrypted.startsWith(actionId)) {\n    throw new Error('Invalid Server Action payload: failed to decrypt.')\n  }\n\n  return decrypted.slice(actionId.length)\n}\n\n/**\n * Encrypt the serialized string with the action id as the salt. Add a prefix to\n * later ensure that the payload is correctly decrypted, similar to a checksum.\n */\nasync function encodeActionBoundArg(actionId: string, arg: string) {\n  const key = await getActionEncryptionKey()\n  if (key === undefined) {\n    throw new Error(\n      `Missing encryption key for Server Action. This is a bug in Next.js`\n    )\n  }\n\n  // Get 16 random bytes as iv.\n  const randomBytes = new Uint8Array(16)\n  workUnitAsyncStorage.exit(() => crypto.getRandomValues(randomBytes))\n  const ivValue = arrayBufferToString(randomBytes.buffer)\n\n  const encrypted = await encrypt(\n    key,\n    randomBytes,\n    textEncoder.encode(actionId + arg)\n  )\n\n  return btoa(ivValue + arrayBufferToString(encrypted))\n}\n\nenum ReadStatus {\n  Ready,\n  Pending,\n  Complete,\n}\n\n// Encrypts the action's bound args into a string. For the same combination of\n// actionId and args the same cached promise is returned. This ensures reference\n// equality for returned objects from \"use cache\" functions when they're invoked\n// multiple times within one render pass using the same bound args.\nexport const encryptActionBoundArgs = React.cache(\n  async function encryptActionBoundArgs(actionId: string, ...args: any[]) {\n    const workUnitStore = workUnitAsyncStorage.getStore()\n    const cacheSignal = workUnitStore\n      ? getCacheSignal(workUnitStore)\n      : undefined\n\n    const { clientModules } = getClientReferenceManifestForRsc()\n\n    // Create an error before any asynchronous calls, to capture the original\n    // call stack in case we need it when the serialization errors.\n    const error = new Error()\n    Error.captureStackTrace(error, encryptActionBoundArgs)\n\n    let didCatchError = false\n\n    const hangingInputAbortSignal = workUnitStore\n      ? createHangingInputAbortSignal(workUnitStore)\n      : undefined\n\n    let readStatus = ReadStatus.Ready\n    function startReadOnce() {\n      if (readStatus === ReadStatus.Ready) {\n        readStatus = ReadStatus.Pending\n        cacheSignal?.beginRead()\n      }\n    }\n\n    function endReadIfStarted() {\n      if (readStatus === ReadStatus.Pending) {\n        cacheSignal?.endRead()\n      }\n      readStatus = ReadStatus.Complete\n    }\n\n    // streamToString might take longer than a microtask to resolve and then other things\n    // waiting on the cache signal might not realize there is another cache to fill so if\n    // we are no longer waiting on the bound args serialization via the hangingInputAbortSignal\n    // we should eagerly start the cache read to prevent other readers of the cache signal from\n    // missing this cache fill. We use a idempotent function to only start reading once because\n    // it's also possible that streamToString finishes before the hangingInputAbortSignal aborts.\n    if (hangingInputAbortSignal && cacheSignal) {\n      hangingInputAbortSignal.addEventListener('abort', startReadOnce, {\n        once: true,\n      })\n    }\n\n    // Using Flight to serialize the args into a string.\n    const serialized = await streamToString(\n      renderToReadableStream(args, clientModules, {\n        filterStackFrame,\n        signal: hangingInputAbortSignal,\n        onError(err) {\n          if (hangingInputAbortSignal?.aborted) {\n            return\n          }\n\n          // We're only reporting one error at a time, starting with the first.\n          if (didCatchError) {\n            return\n          }\n\n          didCatchError = true\n\n          // Use the original error message together with the previously created\n          // stack, because err.stack is a useless Flight Server call stack.\n          error.message = err instanceof Error ? err.message : String(err)\n        },\n      }),\n      // We pass the abort signal to `streamToString` so that no chunks are\n      // included that are emitted after the signal was already aborted. This\n      // ensures that we can encode hanging promises.\n      hangingInputAbortSignal\n    )\n\n    if (didCatchError) {\n      if (process.env.NODE_ENV === 'development') {\n        // Logging the error is needed for server functions that are passed to the\n        // client where the decryption is not done during rendering. Console\n        // replaying allows us to still show the error dev overlay in this case.\n        console.error(error)\n      }\n\n      endReadIfStarted()\n      throw error\n    }\n\n    if (!workUnitStore) {\n      // We don't need to call cacheSignal.endRead here because we can't have a cacheSignal\n      // if we do not have a workUnitStore.\n      return encodeActionBoundArg(actionId, serialized)\n    }\n\n    startReadOnce()\n\n    const prerenderResumeDataCache = getPrerenderResumeDataCache(workUnitStore)\n    const renderResumeDataCache = getRenderResumeDataCache(workUnitStore)\n    const cacheKey = actionId + serialized\n\n    const cachedEncrypted =\n      prerenderResumeDataCache?.encryptedBoundArgs.get(cacheKey) ??\n      renderResumeDataCache?.encryptedBoundArgs.get(cacheKey)\n\n    if (cachedEncrypted) {\n      return cachedEncrypted\n    }\n\n    const encrypted = await encodeActionBoundArg(actionId, serialized)\n\n    endReadIfStarted()\n    prerenderResumeDataCache?.encryptedBoundArgs.set(cacheKey, encrypted)\n\n    return encrypted\n  }\n)\n\n// Decrypts the action's bound args from the encrypted string.\nexport async function decryptActionBoundArgs(\n  actionId: string,\n  encryptedPromise: Promise<string>\n) {\n  const encrypted = await encryptedPromise\n  const workUnitStore = workUnitAsyncStorage.getStore()\n\n  let decrypted: string | undefined\n\n  if (workUnitStore) {\n    const cacheSignal = getCacheSignal(workUnitStore)\n    const prerenderResumeDataCache = getPrerenderResumeDataCache(workUnitStore)\n    const renderResumeDataCache = getRenderResumeDataCache(workUnitStore)\n\n    decrypted =\n      prerenderResumeDataCache?.decryptedBoundArgs.get(encrypted) ??\n      renderResumeDataCache?.decryptedBoundArgs.get(encrypted)\n\n    if (!decrypted) {\n      cacheSignal?.beginRead()\n      decrypted = await decodeActionBoundArg(actionId, encrypted)\n      cacheSignal?.endRead()\n      prerenderResumeDataCache?.decryptedBoundArgs.set(encrypted, decrypted)\n    }\n  } else {\n    decrypted = await decodeActionBoundArg(actionId, encrypted)\n  }\n\n  const { edgeRscModuleMapping, rscModuleMapping } =\n    getClientReferenceManifestForRsc()\n\n  // Using Flight to deserialize the args from the string.\n  const deserialized = await createFromReadableStream(\n    new ReadableStream({\n      start(controller) {\n        controller.enqueue(textEncoder.encode(decrypted))\n\n        switch (workUnitStore?.type) {\n          case 'prerender':\n          case 'prerender-runtime':\n            // Explicitly don't close the stream here (until prerendering is\n            // complete) so that hanging promises are not rejected.\n            if (workUnitStore.renderSignal.aborted) {\n              controller.close()\n            } else {\n              workUnitStore.renderSignal.addEventListener(\n                'abort',\n                () => controller.close(),\n                { once: true }\n              )\n            }\n            break\n          case 'prerender-client':\n          case 'prerender-ppr':\n          case 'prerender-legacy':\n          case 'request':\n          case 'cache':\n          case 'private-cache':\n          case 'unstable-cache':\n          case undefined:\n            return controller.close()\n          default:\n            workUnitStore satisfies never\n        }\n      },\n    }),\n    {\n      findSourceMapURL,\n      serverConsumerManifest: {\n        // moduleLoading must be null because we don't want to trigger preloads of ClientReferences\n        // to be added to the current execution. Instead, we'll wait for any ClientReference\n        // to be emitted which themselves will handle the preloading.\n        moduleLoading: null,\n        moduleMap: isEdgeRuntime ? edgeRscModuleMapping : rscModuleMapping,\n        serverModuleMap: getServerModuleMap(),\n      },\n    }\n  )\n\n  return deserialized\n}\n","export {\n  RequestCookies,\n  ResponseCookies,\n  stringifyCookie,\n} from 'next/dist/compiled/@edge-runtime/cookies'\n","export class ReflectAdapter {\n  static get<T extends object>(\n    target: T,\n    prop: string | symbol,\n    receiver: unknown\n  ): any {\n    const value = Reflect.get(target, prop, receiver)\n    if (typeof value === 'function') {\n      return value.bind(target)\n    }\n\n    return value\n  }\n\n  static set<T extends object>(\n    target: T,\n    prop: string | symbol,\n    value: any,\n    receiver: any\n  ): boolean {\n    return Reflect.set(target, prop, value, receiver)\n  }\n\n  static has<T extends object>(target: T, prop: string | symbol): boolean {\n    return Reflect.has(target, prop)\n  }\n\n  static deleteProperty<T extends object>(\n    target: T,\n    prop: string | symbol\n  ): boolean {\n    return Reflect.deleteProperty(target, prop)\n  }\n}\n","import { RequestCookies } from '../cookies'\n\nimport { ResponseCookies } from '../cookies'\nimport { ReflectAdapter } from './reflect'\nimport { workAsyncStorage } from '../../../app-render/work-async-storage.external'\nimport type { RequestStore } from '../../../app-render/work-unit-async-storage.external'\n\n/**\n * @internal\n */\nexport class ReadonlyRequestCookiesError extends Error {\n  constructor() {\n    super(\n      'Cookies can only be modified in a Server Action or Route Handler. Read more: https://nextjs.org/docs/app/api-reference/functions/cookies#options'\n    )\n  }\n\n  public static callable() {\n    throw new ReadonlyRequestCookiesError()\n  }\n}\n\n// We use this to type some APIs but we don't construct instances directly\nexport type { ResponseCookies }\n\n// The `cookies()` API is a mix of request and response cookies. For `.get()` methods,\n// we want to return the request cookie if it exists. For mutative methods like `.set()`,\n// we want to return the response cookie.\nexport type ReadonlyRequestCookies = Omit<\n  RequestCookies,\n  'set' | 'clear' | 'delete'\n> &\n  Pick<ResponseCookies, 'set' | 'delete'>\n\nexport class RequestCookiesAdapter {\n  public static seal(cookies: RequestCookies): ReadonlyRequestCookies {\n    return new Proxy(cookies as any, {\n      get(target, prop, receiver) {\n        switch (prop) {\n          case 'clear':\n          case 'delete':\n          case 'set':\n            return ReadonlyRequestCookiesError.callable\n          default:\n            return ReflectAdapter.get(target, prop, receiver)\n        }\n      },\n    })\n  }\n}\n\nconst SYMBOL_MODIFY_COOKIE_VALUES = Symbol.for('next.mutated.cookies')\n\nexport function getModifiedCookieValues(\n  cookies: ResponseCookies\n): ResponseCookie[] {\n  const modified: ResponseCookie[] | undefined = (cookies as unknown as any)[\n    SYMBOL_MODIFY_COOKIE_VALUES\n  ]\n  if (!modified || !Array.isArray(modified) || modified.length === 0) {\n    return []\n  }\n\n  return modified\n}\n\ntype SetCookieArgs =\n  | [key: string, value: string, cookie?: Partial<ResponseCookie>]\n  | [options: ResponseCookie]\n\nexport function appendMutableCookies(\n  headers: Headers,\n  mutableCookies: ResponseCookies\n): boolean {\n  const modifiedCookieValues = getModifiedCookieValues(mutableCookies)\n  if (modifiedCookieValues.length === 0) {\n    return false\n  }\n\n  // Return a new response that extends the response with\n  // the modified cookies as fallbacks. `res` cookies\n  // will still take precedence.\n  const resCookies = new ResponseCookies(headers)\n  const returnedCookies = resCookies.getAll()\n\n  // Set the modified cookies as fallbacks.\n  for (const cookie of modifiedCookieValues) {\n    resCookies.set(cookie)\n  }\n\n  // Set the original cookies as the final values.\n  for (const cookie of returnedCookies) {\n    resCookies.set(cookie)\n  }\n\n  return true\n}\n\ntype ResponseCookie = NonNullable<\n  ReturnType<InstanceType<typeof ResponseCookies>['get']>\n>\n\nexport class MutableRequestCookiesAdapter {\n  public static wrap(\n    cookies: RequestCookies,\n    onUpdateCookies?: (cookies: string[]) => void\n  ): ResponseCookies {\n    const responseCookies = new ResponseCookies(new Headers())\n    for (const cookie of cookies.getAll()) {\n      responseCookies.set(cookie)\n    }\n\n    let modifiedValues: ResponseCookie[] = []\n    const modifiedCookies = new Set<string>()\n    const updateResponseCookies = () => {\n      // TODO-APP: change method of getting workStore\n      const workStore = workAsyncStorage.getStore()\n      if (workStore) {\n        workStore.pathWasRevalidated = true\n      }\n\n      const allCookies = responseCookies.getAll()\n      modifiedValues = allCookies.filter((c) => modifiedCookies.has(c.name))\n      if (onUpdateCookies) {\n        const serializedCookies: string[] = []\n        for (const cookie of modifiedValues) {\n          const tempCookies = new ResponseCookies(new Headers())\n          tempCookies.set(cookie)\n          serializedCookies.push(tempCookies.toString())\n        }\n\n        onUpdateCookies(serializedCookies)\n      }\n    }\n\n    const wrappedCookies = new Proxy(responseCookies, {\n      get(target, prop, receiver) {\n        switch (prop) {\n          // A special symbol to get the modified cookie values\n          case SYMBOL_MODIFY_COOKIE_VALUES:\n            return modifiedValues\n\n          // TODO: Throw error if trying to set a cookie after the response\n          // headers have been set.\n          case 'delete':\n            return function (...args: [string] | [ResponseCookie]) {\n              modifiedCookies.add(\n                typeof args[0] === 'string' ? args[0] : args[0].name\n              )\n              try {\n                target.delete(...args)\n                return wrappedCookies\n              } finally {\n                updateResponseCookies()\n              }\n            }\n          case 'set':\n            return function (...args: SetCookieArgs) {\n              modifiedCookies.add(\n                typeof args[0] === 'string' ? args[0] : args[0].name\n              )\n              try {\n                target.set(...args)\n                return wrappedCookies\n              } finally {\n                updateResponseCookies()\n              }\n            }\n\n          default:\n            return ReflectAdapter.get(target, prop, receiver)\n        }\n      },\n    })\n\n    return wrappedCookies\n  }\n}\n\nexport function createCookiesWithMutableAccessCheck(\n  requestStore: RequestStore\n): ResponseCookies {\n  const wrappedCookies = new Proxy(requestStore.mutableCookies, {\n    get(target, prop, receiver) {\n      switch (prop) {\n        case 'delete':\n          return function (...args: [string] | [ResponseCookie]) {\n            ensureCookiesAreStillMutable(requestStore, 'cookies().delete')\n            target.delete(...args)\n            return wrappedCookies\n          }\n        case 'set':\n          return function (...args: SetCookieArgs) {\n            ensureCookiesAreStillMutable(requestStore, 'cookies().set')\n            target.set(...args)\n            return wrappedCookies\n          }\n\n        default:\n          return ReflectAdapter.get(target, prop, receiver)\n      }\n    },\n  })\n  return wrappedCookies\n}\n\nexport function areCookiesMutableInCurrentPhase(requestStore: RequestStore) {\n  return requestStore.phase === 'action'\n}\n\n/** Ensure that cookies() starts throwing on mutation\n * if we changed phases and can no longer mutate.\n *\n * This can happen when going:\n *   'render' -> 'after'\n *   'action' -> 'render'\n * */\nfunction ensureCookiesAreStillMutable(\n  requestStore: RequestStore,\n  _callingExpression: string\n) {\n  if (!areCookiesMutableInCurrentPhase(requestStore)) {\n    // TODO: maybe we can give a more precise error message based on callingExpression?\n    throw new ReadonlyRequestCookiesError()\n  }\n}\n\nexport function responseCookiesToRequestCookies(\n  responseCookies: ResponseCookies\n): RequestCookies {\n  const requestCookies = new RequestCookies(new Headers())\n  for (const cookie of responseCookies.getAll()) {\n    requestCookies.set(cookie)\n  }\n  return requestCookies\n}\n","import * as React from 'react'\n\nconst errorRef: { current: null | Error } = { current: null }\n\n// React.cache is currently only available in canary/experimental React channels.\nconst cache =\n  typeof React.cache === 'function'\n    ? React.cache\n    : (fn: (key: unknown) => void) => fn\n\n// When Cache Components is enabled, we record these as errors so that they\n// are captured by the dev overlay as it's more critical to fix these\n// when enabled.\nconst logErrorOrWarn = process.env.__NEXT_CACHE_COMPONENTS\n  ? console.error\n  : console.warn\n\n// We don't want to dedupe across requests.\n// The developer might've just attempted to fix the warning so we should warn again if it still happens.\nconst flushCurrentErrorIfNew = cache(\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars -- cache key\n  (key: unknown) => {\n    try {\n      logErrorOrWarn(errorRef.current)\n    } finally {\n      errorRef.current = null\n    }\n  }\n)\n\n/**\n * Creates a function that logs an error message that is deduped by the userland\n * callsite.\n * This requires no indirection between the call of this function and the userland\n * callsite i.e. there's only a single library frame above this.\n * Do not use on the Client where sourcemaps and ignore listing might be enabled.\n * Only use that for warnings need a fix independent of the callstack.\n *\n * @param getMessage\n * @returns\n */\nexport function createDedupedByCallsiteServerErrorLoggerDev<Args extends any[]>(\n  getMessage: (...args: Args) => Error\n) {\n  return function logDedupedError(...args: Args) {\n    const message = getMessage(...args)\n\n    if (process.env.NODE_ENV !== 'production') {\n      const callStackFrames = new Error().stack?.split('\\n')\n      if (callStackFrames === undefined || callStackFrames.length < 4) {\n        logErrorOrWarn(message)\n      } else {\n        // Error:\n        //   logDedupedError\n        //   asyncApiBeingAccessedSynchronously\n        //   <userland callsite>\n        // TODO: This breaks if sourcemaps with ignore lists are enabled.\n        const key = callStackFrames[4]\n        errorRef.current = message\n        flushCurrentErrorIfNew(key)\n      }\n    } else {\n      logErrorOrWarn(message)\n    }\n  }\n}\n","import { StaticGenBailoutError } from '../../client/components/static-generation-bailout'\nimport { afterTaskAsyncStorage } from '../app-render/after-task-async-storage.external'\nimport type { WorkStore } from '../app-render/work-async-storage.external'\n\nexport function throwWithStaticGenerationBailoutErrorWithDynamicError(\n  route: string,\n  expression: string\n): never {\n  throw new StaticGenBailoutError(\n    `Route ${route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n  )\n}\n\nexport function throwForSearchParamsAccessInUseCache(\n  workStore: WorkStore,\n  constructorOpt: Function\n): never {\n  const error = new Error(\n    `Route ${workStore.route} used \\`searchParams\\` inside \"use cache\". Accessing dynamic request data inside a cache scope is not supported. If you need some search params inside a cached function await \\`searchParams\\` outside of the cached function and pass only the required search params as arguments to the cached function. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`\n  )\n\n  Error.captureStackTrace(error, constructorOpt)\n  workStore.invalidDynamicUsageError ??= error\n\n  throw error\n}\n\nexport function isRequestAPICallableInsideAfter() {\n  const afterTaskStore = afterTaskAsyncStorage.getStore()\n  return afterTaskStore?.rootTaskSpawnPhase === 'action'\n}\n","import {\n  type ReadonlyRequestCookies,\n  areCookiesMutableInCurrentPhase,\n  RequestCookiesAdapter,\n} from '../web/spec-extension/adapters/request-cookies'\nimport { RequestCookies } from '../web/spec-extension/cookies'\nimport {\n  workAsyncStorage,\n  type WorkStore,\n} from '../app-render/work-async-storage.external'\nimport {\n  throwForMissingRequestStore,\n  workUnitAsyncStorage,\n  type PrerenderStoreModern,\n  type RequestStore,\n} from '../app-render/work-unit-async-storage.external'\nimport {\n  delayUntilRuntimeStage,\n  postponeWithTracking,\n  throwToInterruptStaticGeneration,\n  trackDynamicDataInDynamicRender,\n} from '../app-render/dynamic-rendering'\nimport { StaticGenBailoutError } from '../../client/components/static-generation-bailout'\nimport {\n  makeDevtoolsIOAwarePromise,\n  makeHangingPromise,\n} from '../dynamic-rendering-utils'\nimport { createDedupedByCallsiteServerErrorLoggerDev } from '../create-deduped-by-callsite-server-error-logger'\nimport { isRequestAPICallableInsideAfter } from './utils'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport { RenderStage } from '../app-render/staged-rendering'\n\nexport function cookies(): Promise<ReadonlyRequestCookies> {\n  const callingExpression = 'cookies'\n  const workStore = workAsyncStorage.getStore()\n  const workUnitStore = workUnitAsyncStorage.getStore()\n\n  if (workStore) {\n    if (\n      workUnitStore &&\n      workUnitStore.phase === 'after' &&\n      !isRequestAPICallableInsideAfter()\n    ) {\n      throw new Error(\n        // TODO(after): clarify that this only applies to pages?\n        `Route ${workStore.route} used \\`cookies()\\` inside \\`after()\\`. This is not supported. If you need this data inside an \\`after()\\` callback, use \\`cookies()\\` outside of the callback. See more info here: https://nextjs.org/docs/canary/app/api-reference/functions/after`\n      )\n    }\n\n    if (workStore.forceStatic) {\n      // When using forceStatic we override all other logic and always just return an empty\n      // cookies object without tracking\n      const underlyingCookies = createEmptyCookies()\n      return makeUntrackedCookies(underlyingCookies)\n    }\n\n    if (workStore.dynamicShouldError) {\n      throw new StaticGenBailoutError(\n        `Route ${workStore.route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`cookies()\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n      )\n    }\n\n    if (workUnitStore) {\n      switch (workUnitStore.type) {\n        case 'cache':\n          const error = new Error(\n            `Route ${workStore.route} used \\`cookies()\\` inside \"use cache\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \\`cookies()\\` outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`\n          )\n          Error.captureStackTrace(error, cookies)\n          workStore.invalidDynamicUsageError ??= error\n          throw error\n        case 'unstable-cache':\n          throw new Error(\n            `Route ${workStore.route} used \\`cookies()\\` inside a function cached with \\`unstable_cache()\\`. Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \\`cookies()\\` outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`\n          )\n        case 'prerender':\n          return makeHangingCookies(workStore, workUnitStore)\n        case 'prerender-client':\n          const exportName = '`cookies`'\n          throw new InvariantError(\n            `${exportName} must not be used within a Client Component. Next.js should be preventing ${exportName} from being included in Client Components statically, but did not in this case.`\n          )\n        case 'prerender-ppr':\n          // We need track dynamic access here eagerly to keep continuity with\n          // how cookies has worked in PPR without cacheComponents.\n          return postponeWithTracking(\n            workStore.route,\n            callingExpression,\n            workUnitStore.dynamicTracking\n          )\n        case 'prerender-legacy':\n          // We track dynamic access here so we don't need to wrap the cookies\n          // in individual property access tracking.\n          return throwToInterruptStaticGeneration(\n            callingExpression,\n            workStore,\n            workUnitStore\n          )\n        case 'prerender-runtime':\n          return delayUntilRuntimeStage(\n            workUnitStore,\n            makeUntrackedCookies(workUnitStore.cookies)\n          )\n        case 'private-cache':\n          // Private caches are delayed until the runtime stage in use-cache-wrapper,\n          // so we don't need an additional delay here.\n          return makeUntrackedCookies(workUnitStore.cookies)\n        case 'request':\n          trackDynamicDataInDynamicRender(workUnitStore)\n\n          let underlyingCookies: ReadonlyRequestCookies\n\n          if (areCookiesMutableInCurrentPhase(workUnitStore)) {\n            // We can't conditionally return different types here based on the context.\n            // To avoid confusion, we always return the readonly type here.\n            underlyingCookies =\n              workUnitStore.userspaceMutableCookies as unknown as ReadonlyRequestCookies\n          } else {\n            underlyingCookies = workUnitStore.cookies\n          }\n\n          if (process.env.NODE_ENV === 'development') {\n            // Semantically we only need the dev tracking when running in `next dev`\n            // but since you would never use next dev with production NODE_ENV we use this\n            // as a proxy so we can statically exclude this code from production builds.\n            return makeUntrackedCookiesWithDevWarnings(\n              workUnitStore,\n              underlyingCookies,\n              workStore?.route\n            )\n          } else {\n            return makeUntrackedCookies(underlyingCookies)\n          }\n        default:\n          workUnitStore satisfies never\n      }\n    }\n  }\n\n  // If we end up here, there was no work store or work unit store present.\n  throwForMissingRequestStore(callingExpression)\n}\n\nfunction createEmptyCookies(): ReadonlyRequestCookies {\n  return RequestCookiesAdapter.seal(new RequestCookies(new Headers({})))\n}\n\ninterface CacheLifetime {}\nconst CachedCookies = new WeakMap<\n  CacheLifetime,\n  Promise<ReadonlyRequestCookies>\n>()\n\nfunction makeHangingCookies(\n  workStore: WorkStore,\n  prerenderStore: PrerenderStoreModern\n): Promise<ReadonlyRequestCookies> {\n  const cachedPromise = CachedCookies.get(prerenderStore)\n  if (cachedPromise) {\n    return cachedPromise\n  }\n\n  const promise = makeHangingPromise<ReadonlyRequestCookies>(\n    prerenderStore.renderSignal,\n    workStore.route,\n    '`cookies()`'\n  )\n  CachedCookies.set(prerenderStore, promise)\n\n  return promise\n}\n\nfunction makeUntrackedCookies(\n  underlyingCookies: ReadonlyRequestCookies\n): Promise<ReadonlyRequestCookies> {\n  const cachedCookies = CachedCookies.get(underlyingCookies)\n  if (cachedCookies) {\n    return cachedCookies\n  }\n\n  const promise = Promise.resolve(underlyingCookies)\n  CachedCookies.set(underlyingCookies, promise)\n\n  return promise\n}\n\nfunction makeUntrackedCookiesWithDevWarnings(\n  requestStore: RequestStore,\n  underlyingCookies: ReadonlyRequestCookies,\n  route?: string\n): Promise<ReadonlyRequestCookies> {\n  if (requestStore.asyncApiPromises) {\n    let promise: Promise<ReadonlyRequestCookies>\n    if (underlyingCookies === requestStore.mutableCookies) {\n      promise = requestStore.asyncApiPromises.mutableCookies\n    } else if (underlyingCookies === requestStore.cookies) {\n      promise = requestStore.asyncApiPromises.cookies\n    } else {\n      throw new InvariantError(\n        'Received an underlying cookies object that does not match either `cookies` or `mutableCookies`'\n      )\n    }\n    return instrumentCookiesPromiseWithDevWarnings(promise, route)\n  }\n\n  const cachedCookies = CachedCookies.get(underlyingCookies)\n  if (cachedCookies) {\n    return cachedCookies\n  }\n\n  const promise = makeDevtoolsIOAwarePromise(\n    underlyingCookies,\n    requestStore,\n    RenderStage.Runtime\n  )\n\n  const proxiedPromise = instrumentCookiesPromiseWithDevWarnings(promise, route)\n\n  CachedCookies.set(underlyingCookies, proxiedPromise)\n\n  return proxiedPromise\n}\n\nconst warnForSyncAccess = createDedupedByCallsiteServerErrorLoggerDev(\n  createCookiesAccessError\n)\n\nfunction instrumentCookiesPromiseWithDevWarnings(\n  promise: Promise<ReadonlyRequestCookies>,\n  route: string | undefined\n) {\n  Object.defineProperties(promise, {\n    [Symbol.iterator]: replaceableWarningDescriptorForSymbolIterator(\n      promise,\n      route\n    ),\n    size: replaceableWarningDescriptor(promise, 'size', route),\n    get: replaceableWarningDescriptor(promise, 'get', route),\n    getAll: replaceableWarningDescriptor(promise, 'getAll', route),\n    has: replaceableWarningDescriptor(promise, 'has', route),\n    set: replaceableWarningDescriptor(promise, 'set', route),\n    delete: replaceableWarningDescriptor(promise, 'delete', route),\n    clear: replaceableWarningDescriptor(promise, 'clear', route),\n    toString: replaceableWarningDescriptor(promise, 'toString', route),\n  })\n  return promise\n}\n\nfunction replaceableWarningDescriptor(\n  target: unknown,\n  prop: string,\n  route: string | undefined\n) {\n  return {\n    enumerable: false,\n    get() {\n      warnForSyncAccess(route, `\\`cookies().${prop}\\``)\n      return undefined\n    },\n    set(value: unknown) {\n      Object.defineProperty(target, prop, {\n        value,\n        writable: true,\n        configurable: true,\n      })\n    },\n    configurable: true,\n  }\n}\n\nfunction replaceableWarningDescriptorForSymbolIterator(\n  target: unknown,\n  route: string | undefined\n) {\n  return {\n    enumerable: false,\n    get() {\n      warnForSyncAccess(route, '`...cookies()` or similar iteration')\n      return undefined\n    },\n    set(value: unknown) {\n      Object.defineProperty(target, Symbol.iterator, {\n        value,\n        writable: true,\n        enumerable: true,\n        configurable: true,\n      })\n    },\n    configurable: true,\n  }\n}\n\nfunction createCookiesAccessError(\n  route: string | undefined,\n  expression: string\n) {\n  const prefix = route ? `Route \"${route}\" ` : 'This route '\n  return new Error(\n    `${prefix}used ${expression}. ` +\n      `\\`cookies()\\` returns a Promise and must be unwrapped with \\`await\\` or \\`React.use()\\` before accessing its properties. ` +\n      `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n  )\n}\n","import type { IncomingHttpHeaders } from 'http'\n\nimport { ReflectAdapter } from './reflect'\n\n/**\n * @internal\n */\nexport class ReadonlyHeadersError extends Error {\n  constructor() {\n    super(\n      'Headers cannot be modified. Read more: https://nextjs.org/docs/app/api-reference/functions/headers'\n    )\n  }\n\n  public static callable() {\n    throw new ReadonlyHeadersError()\n  }\n}\n\nexport type ReadonlyHeaders = Headers & {\n  /** @deprecated Method unavailable on `ReadonlyHeaders`. Read more: https://nextjs.org/docs/app/api-reference/functions/headers */\n  append(...args: any[]): void\n  /** @deprecated Method unavailable on `ReadonlyHeaders`. Read more: https://nextjs.org/docs/app/api-reference/functions/headers */\n  set(...args: any[]): void\n  /** @deprecated Method unavailable on `ReadonlyHeaders`. Read more: https://nextjs.org/docs/app/api-reference/functions/headers */\n  delete(...args: any[]): void\n}\nexport class HeadersAdapter extends Headers {\n  private readonly headers: IncomingHttpHeaders\n\n  constructor(headers: IncomingHttpHeaders) {\n    // We've already overridden the methods that would be called, so we're just\n    // calling the super constructor to ensure that the instanceof check works.\n    super()\n\n    this.headers = new Proxy(headers, {\n      get(target, prop, receiver) {\n        // Because this is just an object, we expect that all \"get\" operations\n        // are for properties. If it's a \"get\" for a symbol, we'll just return\n        // the symbol.\n        if (typeof prop === 'symbol') {\n          return ReflectAdapter.get(target, prop, receiver)\n        }\n\n        const lowercased = prop.toLowerCase()\n\n        // Let's find the original casing of the key. This assumes that there is\n        // no mixed case keys (e.g. \"Content-Type\" and \"content-type\") in the\n        // headers object.\n        const original = Object.keys(headers).find(\n          (o) => o.toLowerCase() === lowercased\n        )\n\n        // If the original casing doesn't exist, return undefined.\n        if (typeof original === 'undefined') return\n\n        // If the original casing exists, return the value.\n        return ReflectAdapter.get(target, original, receiver)\n      },\n      set(target, prop, value, receiver) {\n        if (typeof prop === 'symbol') {\n          return ReflectAdapter.set(target, prop, value, receiver)\n        }\n\n        const lowercased = prop.toLowerCase()\n\n        // Let's find the original casing of the key. This assumes that there is\n        // no mixed case keys (e.g. \"Content-Type\" and \"content-type\") in the\n        // headers object.\n        const original = Object.keys(headers).find(\n          (o) => o.toLowerCase() === lowercased\n        )\n\n        // If the original casing doesn't exist, use the prop as the key.\n        return ReflectAdapter.set(target, original ?? prop, value, receiver)\n      },\n      has(target, prop) {\n        if (typeof prop === 'symbol') return ReflectAdapter.has(target, prop)\n\n        const lowercased = prop.toLowerCase()\n\n        // Let's find the original casing of the key. This assumes that there is\n        // no mixed case keys (e.g. \"Content-Type\" and \"content-type\") in the\n        // headers object.\n        const original = Object.keys(headers).find(\n          (o) => o.toLowerCase() === lowercased\n        )\n\n        // If the original casing doesn't exist, return false.\n        if (typeof original === 'undefined') return false\n\n        // If the original casing exists, return true.\n        return ReflectAdapter.has(target, original)\n      },\n      deleteProperty(target, prop) {\n        if (typeof prop === 'symbol')\n          return ReflectAdapter.deleteProperty(target, prop)\n\n        const lowercased = prop.toLowerCase()\n\n        // Let's find the original casing of the key. This assumes that there is\n        // no mixed case keys (e.g. \"Content-Type\" and \"content-type\") in the\n        // headers object.\n        const original = Object.keys(headers).find(\n          (o) => o.toLowerCase() === lowercased\n        )\n\n        // If the original casing doesn't exist, return true.\n        if (typeof original === 'undefined') return true\n\n        // If the original casing exists, delete the property.\n        return ReflectAdapter.deleteProperty(target, original)\n      },\n    })\n  }\n\n  /**\n   * Seals a Headers instance to prevent modification by throwing an error when\n   * any mutating method is called.\n   */\n  public static seal(headers: Headers): ReadonlyHeaders {\n    return new Proxy<ReadonlyHeaders>(headers, {\n      get(target, prop, receiver) {\n        switch (prop) {\n          case 'append':\n          case 'delete':\n          case 'set':\n            return ReadonlyHeadersError.callable\n          default:\n            return ReflectAdapter.get(target, prop, receiver)\n        }\n      },\n    })\n  }\n\n  /**\n   * Merges a header value into a string. This stores multiple values as an\n   * array, so we need to merge them into a string.\n   *\n   * @param value a header value\n   * @returns a merged header value (a string)\n   */\n  private merge(value: string | string[]): string {\n    if (Array.isArray(value)) return value.join(', ')\n\n    return value\n  }\n\n  /**\n   * Creates a Headers instance from a plain object or a Headers instance.\n   *\n   * @param headers a plain object or a Headers instance\n   * @returns a headers instance\n   */\n  public static from(headers: IncomingHttpHeaders | Headers): Headers {\n    if (headers instanceof Headers) return headers\n\n    return new HeadersAdapter(headers)\n  }\n\n  public append(name: string, value: string): void {\n    const existing = this.headers[name]\n    if (typeof existing === 'string') {\n      this.headers[name] = [existing, value]\n    } else if (Array.isArray(existing)) {\n      existing.push(value)\n    } else {\n      this.headers[name] = value\n    }\n  }\n\n  public delete(name: string): void {\n    delete this.headers[name]\n  }\n\n  public get(name: string): string | null {\n    const value = this.headers[name]\n    if (typeof value !== 'undefined') return this.merge(value)\n\n    return null\n  }\n\n  public has(name: string): boolean {\n    return typeof this.headers[name] !== 'undefined'\n  }\n\n  public set(name: string, value: string): void {\n    this.headers[name] = value\n  }\n\n  public forEach(\n    callbackfn: (value: string, name: string, parent: Headers) => void,\n    thisArg?: any\n  ): void {\n    for (const [name, value] of this.entries()) {\n      callbackfn.call(thisArg, value, name, this)\n    }\n  }\n\n  public *entries(): HeadersIterator<[string, string]> {\n    for (const key of Object.keys(this.headers)) {\n      const name = key.toLowerCase()\n      // We assert here that this is a string because we got it from the\n      // Object.keys() call above.\n      const value = this.get(name) as string\n\n      yield [name, value] as [string, string]\n    }\n  }\n\n  public *keys(): HeadersIterator<string> {\n    for (const key of Object.keys(this.headers)) {\n      const name = key.toLowerCase()\n      yield name\n    }\n  }\n\n  public *values(): HeadersIterator<string> {\n    for (const key of Object.keys(this.headers)) {\n      // We assert here that this is a string because we got it from the\n      // Object.keys() call above.\n      const value = this.get(key) as string\n\n      yield value\n    }\n  }\n\n  public [Symbol.iterator](): HeadersIterator<[string, string]> {\n    return this.entries()\n  }\n}\n","import {\n  HeadersAdapter,\n  type ReadonlyHeaders,\n} from '../web/spec-extension/adapters/headers'\nimport {\n  workAsyncStorage,\n  type WorkStore,\n} from '../app-render/work-async-storage.external'\nimport {\n  throwForMissingRequestStore,\n  workUnitAsyncStorage,\n  type PrerenderStoreModern,\n  type RequestStore,\n} from '../app-render/work-unit-async-storage.external'\nimport {\n  delayUntilRuntimeStage,\n  postponeWithTracking,\n  throwToInterruptStaticGeneration,\n  trackDynamicDataInDynamicRender,\n} from '../app-render/dynamic-rendering'\nimport { StaticGenBailoutError } from '../../client/components/static-generation-bailout'\nimport {\n  makeDevtoolsIOAwarePromise,\n  makeHangingPromise,\n} from '../dynamic-rendering-utils'\nimport { createDedupedByCallsiteServerErrorLoggerDev } from '../create-deduped-by-callsite-server-error-logger'\nimport { isRequestAPICallableInsideAfter } from './utils'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport { RenderStage } from '../app-render/staged-rendering'\n\n/**\n * This function allows you to read the HTTP incoming request headers in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers) and\n * [Middleware](https://nextjs.org/docs/app/building-your-application/routing/middleware).\n *\n * Read more: [Next.js Docs: `headers`](https://nextjs.org/docs/app/api-reference/functions/headers)\n */\nexport function headers(): Promise<ReadonlyHeaders> {\n  const callingExpression = 'headers'\n  const workStore = workAsyncStorage.getStore()\n  const workUnitStore = workUnitAsyncStorage.getStore()\n\n  if (workStore) {\n    if (\n      workUnitStore &&\n      workUnitStore.phase === 'after' &&\n      !isRequestAPICallableInsideAfter()\n    ) {\n      throw new Error(\n        `Route ${workStore.route} used \\`headers()\\` inside \\`after()\\`. This is not supported. If you need this data inside an \\`after()\\` callback, use \\`headers()\\` outside of the callback. See more info here: https://nextjs.org/docs/canary/app/api-reference/functions/after`\n      )\n    }\n\n    if (workStore.forceStatic) {\n      // When using forceStatic we override all other logic and always just return an empty\n      // headers object without tracking\n      const underlyingHeaders = HeadersAdapter.seal(new Headers({}))\n      return makeUntrackedHeaders(underlyingHeaders)\n    }\n\n    if (workUnitStore) {\n      switch (workUnitStore.type) {\n        case 'cache': {\n          const error = new Error(\n            `Route ${workStore.route} used \\`headers()\\` inside \"use cache\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \\`headers()\\` outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`\n          )\n          Error.captureStackTrace(error, headers)\n          workStore.invalidDynamicUsageError ??= error\n          throw error\n        }\n        case 'unstable-cache':\n          throw new Error(\n            `Route ${workStore.route} used \\`headers()\\` inside a function cached with \\`unstable_cache()\\`. Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \\`headers()\\` outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`\n          )\n        case 'prerender':\n        case 'prerender-client':\n        case 'private-cache':\n        case 'prerender-runtime':\n        case 'prerender-ppr':\n        case 'prerender-legacy':\n        case 'request':\n          break\n        default:\n          workUnitStore satisfies never\n      }\n    }\n\n    if (workStore.dynamicShouldError) {\n      throw new StaticGenBailoutError(\n        `Route ${workStore.route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`headers()\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n      )\n    }\n\n    if (workUnitStore) {\n      switch (workUnitStore.type) {\n        case 'prerender':\n          return makeHangingHeaders(workStore, workUnitStore)\n        case 'prerender-client':\n          const exportName = '`headers`'\n          throw new InvariantError(\n            `${exportName} must not be used within a client component. Next.js should be preventing ${exportName} from being included in client components statically, but did not in this case.`\n          )\n        case 'prerender-ppr':\n          // PPR Prerender (no cacheComponents)\n          // We are prerendering with PPR. We need track dynamic access here eagerly\n          // to keep continuity with how headers has worked in PPR without cacheComponents.\n          // TODO consider switching the semantic to throw on property access instead\n          return postponeWithTracking(\n            workStore.route,\n            callingExpression,\n            workUnitStore.dynamicTracking\n          )\n        case 'prerender-legacy':\n          // Legacy Prerender\n          // We are in a legacy static generation mode while prerendering\n          // We track dynamic access here so we don't need to wrap the headers in\n          // individual property access tracking.\n          return throwToInterruptStaticGeneration(\n            callingExpression,\n            workStore,\n            workUnitStore\n          )\n        case 'prerender-runtime':\n          return delayUntilRuntimeStage(\n            workUnitStore,\n            makeUntrackedHeaders(workUnitStore.headers)\n          )\n        case 'private-cache':\n          // Private caches are delayed until the runtime stage in use-cache-wrapper,\n          // so we don't need an additional delay here.\n          return makeUntrackedHeaders(workUnitStore.headers)\n        case 'request':\n          trackDynamicDataInDynamicRender(workUnitStore)\n\n          if (process.env.NODE_ENV === 'development') {\n            // Semantically we only need the dev tracking when running in `next dev`\n            // but since you would never use next dev with production NODE_ENV we use this\n            // as a proxy so we can statically exclude this code from production builds.\n            return makeUntrackedHeadersWithDevWarnings(\n              workUnitStore.headers,\n              workStore?.route,\n              workUnitStore\n            )\n          } else {\n            return makeUntrackedHeaders(workUnitStore.headers)\n          }\n          break\n        default:\n          workUnitStore satisfies never\n      }\n    }\n  }\n\n  // If we end up here, there was no work store or work unit store present.\n  throwForMissingRequestStore(callingExpression)\n}\n\ninterface CacheLifetime {}\nconst CachedHeaders = new WeakMap<CacheLifetime, Promise<ReadonlyHeaders>>()\n\nfunction makeHangingHeaders(\n  workStore: WorkStore,\n  prerenderStore: PrerenderStoreModern\n): Promise<ReadonlyHeaders> {\n  const cachedHeaders = CachedHeaders.get(prerenderStore)\n  if (cachedHeaders) {\n    return cachedHeaders\n  }\n\n  const promise = makeHangingPromise<ReadonlyHeaders>(\n    prerenderStore.renderSignal,\n    workStore.route,\n    '`headers()`'\n  )\n  CachedHeaders.set(prerenderStore, promise)\n\n  return promise\n}\n\nfunction makeUntrackedHeaders(\n  underlyingHeaders: ReadonlyHeaders\n): Promise<ReadonlyHeaders> {\n  const cachedHeaders = CachedHeaders.get(underlyingHeaders)\n  if (cachedHeaders) {\n    return cachedHeaders\n  }\n\n  const promise = Promise.resolve(underlyingHeaders)\n  CachedHeaders.set(underlyingHeaders, promise)\n\n  return promise\n}\n\nfunction makeUntrackedHeadersWithDevWarnings(\n  underlyingHeaders: ReadonlyHeaders,\n  route: string | undefined,\n  requestStore: RequestStore\n): Promise<ReadonlyHeaders> {\n  if (requestStore.asyncApiPromises) {\n    const promise = requestStore.asyncApiPromises.headers\n    return instrumentHeadersPromiseWithDevWarnings(promise, route)\n  }\n\n  const cachedHeaders = CachedHeaders.get(underlyingHeaders)\n  if (cachedHeaders) {\n    return cachedHeaders\n  }\n\n  const promise = makeDevtoolsIOAwarePromise(\n    underlyingHeaders,\n    requestStore,\n    RenderStage.Runtime\n  )\n\n  const proxiedPromise = instrumentHeadersPromiseWithDevWarnings(promise, route)\n\n  CachedHeaders.set(underlyingHeaders, proxiedPromise)\n\n  return proxiedPromise\n}\n\nconst warnForSyncAccess = createDedupedByCallsiteServerErrorLoggerDev(\n  createHeadersAccessError\n)\n\nfunction instrumentHeadersPromiseWithDevWarnings(\n  promise: Promise<ReadonlyHeaders>,\n  route: string | undefined\n) {\n  Object.defineProperties(promise, {\n    [Symbol.iterator]: replaceableWarningDescriptorForSymbolIterator(\n      promise,\n      route\n    ),\n    append: replaceableWarningDescriptor(promise, 'append', route),\n    delete: replaceableWarningDescriptor(promise, 'delete', route),\n    get: replaceableWarningDescriptor(promise, 'get', route),\n    has: replaceableWarningDescriptor(promise, 'has', route),\n    set: replaceableWarningDescriptor(promise, 'set', route),\n    getSetCookie: replaceableWarningDescriptor(promise, 'getSetCookie', route),\n    forEach: replaceableWarningDescriptor(promise, 'forEach', route),\n    keys: replaceableWarningDescriptor(promise, 'keys', route),\n    values: replaceableWarningDescriptor(promise, 'values', route),\n    entries: replaceableWarningDescriptor(promise, 'entries', route),\n  })\n  return promise\n}\n\nfunction replaceableWarningDescriptor(\n  target: unknown,\n  prop: string,\n  route: string | undefined\n) {\n  return {\n    enumerable: false,\n    get() {\n      warnForSyncAccess(route, `\\`headers().${prop}\\``)\n      return undefined\n    },\n    set(value: unknown) {\n      Object.defineProperty(target, prop, {\n        value,\n        writable: true,\n        configurable: true,\n      })\n    },\n    configurable: true,\n  }\n}\n\nfunction replaceableWarningDescriptorForSymbolIterator(\n  target: unknown,\n  route: string | undefined\n) {\n  return {\n    enumerable: false,\n    get() {\n      warnForSyncAccess(route, '`...headers()` or similar iteration')\n      return undefined\n    },\n    set(value: unknown) {\n      Object.defineProperty(target, Symbol.iterator, {\n        value,\n        writable: true,\n        enumerable: true,\n        configurable: true,\n      })\n    },\n    configurable: true,\n  }\n}\n\nfunction createHeadersAccessError(\n  route: string | undefined,\n  expression: string\n) {\n  const prefix = route ? `Route \"${route}\" ` : 'This route '\n  return new Error(\n    `${prefix}used ${expression}. ` +\n      `\\`headers()\\` returns a Promise and must be unwrapped with \\`await\\` or \\`React.use()\\` before accessing its properties. ` +\n      `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n  )\n}\n","import {\n  getDraftModeProviderForCacheScope,\n  throwForMissingRequestStore,\n} from '../app-render/work-unit-async-storage.external'\n\nimport type { DraftModeProvider } from '../async-storage/draft-mode-provider'\n\nimport {\n  workAsyncStorage,\n  type WorkStore,\n} from '../app-render/work-async-storage.external'\nimport { workUnitAsyncStorage } from '../app-render/work-unit-async-storage.external'\nimport {\n  abortAndThrowOnSynchronousRequestDataAccess,\n  delayUntilRuntimeStage,\n  postponeWithTracking,\n  trackDynamicDataInDynamicRender,\n} from '../app-render/dynamic-rendering'\nimport { createDedupedByCallsiteServerErrorLoggerDev } from '../create-deduped-by-callsite-server-error-logger'\nimport { StaticGenBailoutError } from '../../client/components/static-generation-bailout'\nimport { DynamicServerError } from '../../client/components/hooks-server-context'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport { ReflectAdapter } from '../web/spec-extension/adapters/reflect'\n\nexport function draftMode(): Promise<DraftMode> {\n  const callingExpression = 'draftMode'\n  const workStore = workAsyncStorage.getStore()\n  const workUnitStore = workUnitAsyncStorage.getStore()\n\n  if (!workStore || !workUnitStore) {\n    throwForMissingRequestStore(callingExpression)\n  }\n\n  switch (workUnitStore.type) {\n    case 'prerender-runtime':\n      // TODO(runtime-ppr): does it make sense to delay this? normally it's always microtasky\n      return delayUntilRuntimeStage(\n        workUnitStore,\n        createOrGetCachedDraftMode(workUnitStore.draftMode, workStore)\n      )\n    case 'request':\n      return createOrGetCachedDraftMode(workUnitStore.draftMode, workStore)\n\n    case 'cache':\n    case 'private-cache':\n    case 'unstable-cache':\n      // Inside of `\"use cache\"` or `unstable_cache`, draft mode is available if\n      // the outmost work unit store is a request store (or a runtime prerender),\n      // and if draft mode is enabled.\n      const draftModeProvider = getDraftModeProviderForCacheScope(\n        workStore,\n        workUnitStore\n      )\n\n      if (draftModeProvider) {\n        return createOrGetCachedDraftMode(draftModeProvider, workStore)\n      }\n\n    // Otherwise, we fall through to providing an empty draft mode.\n    // eslint-disable-next-line no-fallthrough\n    case 'prerender':\n    case 'prerender-client':\n    case 'prerender-ppr':\n    case 'prerender-legacy':\n      // Return empty draft mode\n      return createOrGetCachedDraftMode(null, workStore)\n\n    default:\n      return workUnitStore satisfies never\n  }\n}\n\nfunction createOrGetCachedDraftMode(\n  draftModeProvider: DraftModeProvider | null,\n  workStore: WorkStore | undefined\n): Promise<DraftMode> {\n  const cacheKey = draftModeProvider ?? NullDraftMode\n  const cachedDraftMode = CachedDraftModes.get(cacheKey)\n\n  if (cachedDraftMode) {\n    return cachedDraftMode\n  }\n\n  if (process.env.NODE_ENV === 'development' && !workStore?.isPrefetchRequest) {\n    const route = workStore?.route\n    return createDraftModeWithDevWarnings(draftModeProvider, route)\n  } else {\n    return Promise.resolve(new DraftMode(draftModeProvider))\n  }\n}\n\ninterface CacheLifetime {}\nconst NullDraftMode = {}\nconst CachedDraftModes = new WeakMap<CacheLifetime, Promise<DraftMode>>()\n\nfunction createDraftModeWithDevWarnings(\n  underlyingProvider: null | DraftModeProvider,\n  route: undefined | string\n): Promise<DraftMode> {\n  const instance = new DraftMode(underlyingProvider)\n  const promise = Promise.resolve(instance)\n\n  const proxiedPromise = new Proxy(promise, {\n    get(target, prop, receiver) {\n      switch (prop) {\n        case 'isEnabled':\n          warnForSyncAccess(route, `\\`draftMode().${prop}\\``)\n          break\n        case 'enable':\n        case 'disable': {\n          warnForSyncAccess(route, `\\`draftMode().${prop}()\\``)\n          break\n        }\n        default: {\n          // We only warn for well-defined properties of the draftMode object.\n        }\n      }\n\n      return ReflectAdapter.get(target, prop, receiver)\n    },\n  })\n\n  return proxiedPromise\n}\n\nclass DraftMode {\n  /**\n   * @internal - this declaration is stripped via `tsc --stripInternal`\n   */\n  private readonly _provider: null | DraftModeProvider\n\n  constructor(provider: null | DraftModeProvider) {\n    this._provider = provider\n  }\n  get isEnabled() {\n    if (this._provider !== null) {\n      return this._provider.isEnabled\n    }\n    return false\n  }\n  public enable() {\n    // We have a store we want to track dynamic data access to ensure we\n    // don't statically generate routes that manipulate draft mode.\n    trackDynamicDraftMode('draftMode().enable()', this.enable)\n    if (this._provider !== null) {\n      this._provider.enable()\n    }\n  }\n  public disable() {\n    trackDynamicDraftMode('draftMode().disable()', this.disable)\n    if (this._provider !== null) {\n      this._provider.disable()\n    }\n  }\n}\nconst warnForSyncAccess = createDedupedByCallsiteServerErrorLoggerDev(\n  createDraftModeAccessError\n)\n\nfunction createDraftModeAccessError(\n  route: string | undefined,\n  expression: string\n) {\n  const prefix = route ? `Route \"${route}\" ` : 'This route '\n  return new Error(\n    `${prefix}used ${expression}. ` +\n      `\\`draftMode()\\` returns a Promise and must be unwrapped with \\`await\\` or \\`React.use()\\` before accessing its properties. ` +\n      `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n  )\n}\n\nfunction trackDynamicDraftMode(expression: string, constructorOpt: Function) {\n  const workStore = workAsyncStorage.getStore()\n  const workUnitStore = workUnitAsyncStorage.getStore()\n\n  if (workStore) {\n    // We have a store we want to track dynamic data access to ensure we\n    // don't statically generate routes that manipulate draft mode.\n    if (workUnitStore?.phase === 'after') {\n      throw new Error(\n        `Route ${workStore.route} used \"${expression}\" inside \\`after()\\`. The enabled status of \\`draftMode()\\` can be read inside \\`after()\\` but you cannot enable or disable \\`draftMode()\\`. See more info here: https://nextjs.org/docs/app/api-reference/functions/after`\n      )\n    }\n\n    if (workStore.dynamicShouldError) {\n      throw new StaticGenBailoutError(\n        `Route ${workStore.route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n      )\n    }\n\n    if (workUnitStore) {\n      switch (workUnitStore.type) {\n        case 'cache':\n        case 'private-cache': {\n          const error = new Error(\n            `Route ${workStore.route} used \"${expression}\" inside \"use cache\". The enabled status of \\`draftMode()\\` can be read in caches but you must not enable or disable \\`draftMode()\\` inside a cache. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`\n          )\n          Error.captureStackTrace(error, constructorOpt)\n          workStore.invalidDynamicUsageError ??= error\n          throw error\n        }\n        case 'unstable-cache':\n          throw new Error(\n            `Route ${workStore.route} used \"${expression}\" inside a function cached with \\`unstable_cache()\\`. The enabled status of \\`draftMode()\\` can be read in caches but you must not enable or disable \\`draftMode()\\` inside a cache. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`\n          )\n\n        case 'prerender':\n        case 'prerender-runtime': {\n          const error = new Error(\n            `Route ${workStore.route} used ${expression} without first calling \\`await connection()\\`. See more info here: https://nextjs.org/docs/messages/next-prerender-sync-headers`\n          )\n          return abortAndThrowOnSynchronousRequestDataAccess(\n            workStore.route,\n            expression,\n            error,\n            workUnitStore\n          )\n        }\n        case 'prerender-client':\n          const exportName = '`draftMode`'\n          throw new InvariantError(\n            `${exportName} must not be used within a Client Component. Next.js should be preventing ${exportName} from being included in Client Components statically, but did not in this case.`\n          )\n        case 'prerender-ppr':\n          return postponeWithTracking(\n            workStore.route,\n            expression,\n            workUnitStore.dynamicTracking\n          )\n        case 'prerender-legacy':\n          workUnitStore.revalidate = 0\n\n          const err = new DynamicServerError(\n            `Route ${workStore.route} couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`\n          )\n          workStore.dynamicUsageDescription = expression\n          workStore.dynamicUsageStack = err.stack\n\n          throw err\n        case 'request':\n          trackDynamicDataInDynamicRender(workUnitStore)\n          break\n        default:\n          workUnitStore satisfies never\n      }\n    }\n  }\n}\n","module.exports.cookies = require('./dist/server/request/cookies').cookies\nmodule.exports.headers = require('./dist/server/request/headers').headers\nmodule.exports.draftMode = require('./dist/server/request/draft-mode').draftMode\n","// This function ensures that all the exported values are valid server actions,\n// during the runtime. By definition all actions are required to be async\n// functions, but here we can only check that they are functions.\nexport function ensureServerEntryExports(actions: any[]) {\n  for (let i = 0; i < actions.length; i++) {\n    const action = actions[i]\n    if (typeof action !== 'function') {\n      throw new Error(\n        `A \"use server\" file can only export async functions, found ${typeof action}.\\nRead more: https://nextjs.org/docs/messages/invalid-use-server-value`\n      )\n    }\n  }\n}\n"],"names":["registerServerReference","AppRenderSpan","AppRouteRouteHandlersSpan","BaseServerSpan","LoadComponentsSpan","LogSpanAllowList","MiddlewareSpan","NextNodeServerSpan","NextServerSpan","NextVanillaSpanAllowlist","NodeSpan","RenderSpan","ResolveMetadataSpan","RouterSpan","StartServerSpan","isThenable","promise","then","BubbledError","SpanKind","SpanStatusCode","getTracer","isBubbledError","api","process","env","NEXT_RUNTIME","require","err","context","propagation","trace","ROOT_CONTEXT","Error","constructor","bubble","result","error","closeSpanWithError","span","setAttribute","recordException","name","setStatus","code","ERROR","message","end","rootSpanAttributesStore","Map","rootSpanIdKey","createContextKey","lastSpanId","getSpanId","clientTraceDataSetter","set","carrier","key","value","push","NextTracerImpl","getTracerInstance","getContext","getTracePropagationData","activeContext","active","entries","inject","getActiveScopeSpan","getSpan","withPropagatedContext","fn","getter","getSpanContext","remoteContext","extract","with","args","type","fnOrOptions","fnOrEmpty","options","spanName","includes","NEXT_OTEL_VERBOSE","hideSpan","spanContext","parentSpan","isRootSpan","isRemote","spanId","attributes","setValue","startActiveSpan","startTime","globalThis","performance","now","undefined","onCleanup","delete","NEXT_OTEL_PERFORMANCE_PREFIX","measure","split","pop","replace","match","toLowerCase","start","Object","length","res","catch","finally","wrap","tracer","optionsObj","apply","arguments","lastArgId","cb","scopeBoundCb","bind","_span","done","startSpan","setSpan","getRootSpanAttributes","getValue","get","setRootSpanAttribute","has","DetachedPromise","resolve","reject","Promise","rej","atLeastOneTask","scheduleImmediate","scheduleOnNextTick","waitAtLeastOneReactRenderTask","setTimeout","nextTick","setImmediate","r","ENCODED_TAGS","OPENING","HTML","Uint8Array","BODY","CLOSED","HEAD","BODY_AND_HTML","META","ICON_MARK","indexOfUint8Array","isEquivalentUint8Arrays","removeFromUint8Array","a","b","i","completeMatch","j","tagIndex","subarray","removed","slice","MISSING_ROOT_TAGS_ERROR","DOC_PREFETCH_RANGE_HEADER_VALUE","doesExportedHtmlMatchBuildId","insertBuildIdComment","DOCTYPE_PREFIX","MAX_BUILD_ID_LENGTH","escapeBuildId","buildId","truncated","originalHtml","startsWith","partialHtmlDocument","ACTION_HEADER","FLIGHT_HEADERS","NEXT_ACTION_NOT_FOUND_HEADER","NEXT_DID_POSTPONE_HEADER","NEXT_HMR_REFRESH_HASH_COOKIE","NEXT_HMR_REFRESH_HEADER","NEXT_HTML_REQUEST_ID_HEADER","NEXT_IS_PRERENDER_HEADER","NEXT_REQUEST_ID_HEADER","NEXT_REWRITTEN_PATH_HEADER","NEXT_REWRITTEN_QUERY_HEADER","NEXT_ROUTER_PREFETCH_HEADER","NEXT_ROUTER_SEGMENT_PREFETCH_HEADER","NEXT_ROUTER_STALE_TIME_HEADER","NEXT_ROUTER_STATE_TREE_HEADER","NEXT_RSC_UNION_QUERY","NEXT_URL","RSC_CONTENT_TYPE_HEADER","RSC_HEADER","djb2Hash","hexHash","str","hash","char","charCodeAt","toString","computeCacheBustingSearchParam","prefetchHeader","segmentPrefetchHeader","stateTreeHeader","nextUrlHeader","join","chainStreams","continueDynamicHTMLResume","continueDynamicPrerender","continueFizzStream","continueStaticFallbackPrerender","continueStaticPrerender","createBufferedTransformStream","createDocumentClosingStream","createRootLayoutValidatorStream","renderToInitialFizzStream","streamFromBuffer","streamFromString","streamToBuffer","streamToString","voidCatch","encoder","TextEncoder","streams","ReadableStream","controller","close","readable","writable","TransformStream","pipeTo","preventClose","nextStream","lastStream","enqueue","encode","chunk","stream","reader","getReader","chunks","read","Buffer","concat","signal","decoder","TextDecoder","fatal","string","aborted","decode","maxBufferByteLength","Infinity","bufferedChunks","bufferByteLength","pending","flush","copiedBytes","bufferedChunk","byteLength","scheduleFlush","detached","transform","createPrefetchCommentStream","isBuildTimePrerendering","didTransformFirstChunk","chunkStr","updatedChunkStr","ReactDOMServer","element","streamOptions","renderToReadableStream","createMetadataTransformStream","insert","chunkIndex","isMarkRemoved","iconMarkIndex","closedHeadIndex","iconMarkLength","replaced","insertion","encodedInsertion","insertionLength","createHeadInsertionTransformStream","inserted","hasBytes","index","insertedHeadContent","createClientResumeScriptInsertionTransformStream","segmentPath","cacheBustingHeader","searchStr","NEXT_CLIENT_RESUME_SCRIPT","didAlreadyInsert","headClosingTagIndex","createDeferredSuffixStream","suffix","flushed","createFlightDataInjectionTransformStream","delayDataUntilFirstHtmlChunk","htmlStreamFinished","pull","donePulling","startOrContinuePulling","startPulling","CLOSE_TAG","createMoveSuffixStream","foundSuffix","before","after","createStripDocumentClosingTagsTransform","foundHtml","foundBody","missingTags","map","c","chainTransformers","transformers","transformer","pipeThrough","renderStream","inlinedDataStream","isStaticGeneration","getServerInsertedHTML","getServerInsertedMetadata","validateRootLayout","suffixUnclosed","allReady","prerenderStream","InvariantError","endsWith","ensureLeadingSlash","path","DEFAULT_SEGMENT_KEY","PAGE_SEGMENT_KEY","addSearchParamsIfPageSegment","computeSelectedLayoutSegment","getSegmentValue","getSelectedLayoutSegmentPath","isGroupSegment","isParallelRouteSegment","segment","Array","isArray","searchParams","isPageSegment","stringifiedQuery","JSON","stringify","segments","parallelRouteKey","rawSegment","tree","first","node","parallelRoutes","children","values","segmentValue","normalizeAppPath","normalizeRscURL","route","reduce","pathname","url","arrayBufferToString","decrypt","encrypt","getActionEncryptionKey","getClientReferenceManifestForRsc","getServerModuleMap","setReferenceManifestsSingleton","stringToUint8Array","__next_loaded_action_key","buffer","bytes","len","String","fromCharCode","binary","arr","iv","data","crypto","subtle","SERVER_ACTION_MANIFESTS_SINGLETON","Symbol","for","page","clientReferenceManifest","serverActionsManifest","serverModuleMap","clientReferenceManifestsPerPage","serverActionsManifestSingleton","workStore","workAsyncStorage","getStore","mergeClientReferenceManifests","rawKey","NEXT_SERVER_ACTIONS_ENCRYPTION_KEY","encryptionKey","importKey","atob","clientReferenceManifests","mergedClientReferenceManifest","clientModules","edgeRscModuleMapping","rscModuleMapping","DynamicServerError","isDynamicServerError","DYNAMIC_ERROR_CODE","description","digest","StaticGenBailoutError","isStaticGenBailoutError","NEXT_STATIC_GEN_BAILOUT","isHangingPromiseRejectionError","makeDevtoolsIOAwarePromise","makeHangingPromise","HANGING_PROMISE_REJECTION","HangingPromiseRejectionError","expression","abortListenersBySignal","WeakMap","hangingPromise","_","boundRejection","currentListeners","listeners","addEventListener","once","ignoreReject","underlying","requestStore","stage","stagedRendering","delayUntilStage","METADATA_BOUNDARY_NAME","OUTLET_BOUNDARY_NAME","ROOT_LAYOUT_BOUNDARY_NAME","VIEWPORT_BOUNDARY_NAME","BailoutToCSRError","isBailoutToCSRError","BAILOUT_TO_CSR","reason","createPromiseWithResolvers","RenderStage","StagedRenderingController","abortSignal","currentStage","runtimeStagePromise","dynamicStagePromise","advanceStage","getStagePromise","waitForStage","displayName","resolvedValue","ioTriggerPromise","makeDevtoolsIOPromiseFromIOTrigger","ioTrigger","Postpone","PreludeState","abortAndThrowOnSynchronousRequestDataAccess","abortOnSynchronousPlatformIOAccess","accessedDynamicData","annotateDynamicAccess","consumeDynamicAccess","createDynamicTrackingState","createDynamicValidationState","createHangingInputAbortSignal","createRenderInBrowserAbortSignal","delayUntilRuntimeStage","formatDynamicAPIAccesses","getFirstDynamicReason","isDynamicPostpone","isPrerenderInterruptedError","logDisallowedDynamicError","markCurrentScopeAsDynamic","postponeWithTracking","throwIfDisallowedDynamic","throwToInterruptStaticGeneration","trackAllowedDynamicAccess","trackDynamicDataInDynamicRender","trackSynchronousPlatformIOAccessInDev","useDynamicRouteParams","useDynamicSearchParams","hasPostpone","React","unstable_postpone","isDebugDynamicAccesses","dynamicAccesses","syncDynamicErrorWithStack","hasSuspenseAboveBody","hasDynamicMetadata","hasDynamicViewport","hasAllowedDynamic","dynamicErrors","trackingState","store","workUnitStore","forceDynamic","forceStatic","dynamicShouldError","dynamicTracking","revalidate","dynamicUsageDescription","dynamicUsageStack","stack","NODE_ENV","usedDynamic","prerenderStore","abortOnSynchronousDynamicDataAccess","createPrerenderInterruptedError","abort","errorWithStack","Dynamic","prerenderSignal","workUnitAsyncStorage","assertPostpone","createPostponeReason","isDynamicPostponeReason","NEXT_PRERENDER_INTERRUPTED","serverDynamic","clientDynamic","filter","access","line","AbortController","cacheSignal","inputReady","getRuntimeStagePromise","fallbackParams","fallbackRouteParams","size","use","renderSignal","throwForMissingRequestStore","hasSuspenseRegex","bodyAndImplicitTags","hasSuspenseBeforeRootLayoutWithoutBodyOrImplicitBodyRegex","RegExp","hasMetadataRegex","hasViewportRegex","hasOutletRegex","componentStack","dynamicValidation","test","createErrorWithComponentOrOwnerStack","ownerStack","captureOwnerStack","console","dev","hasReadableErrorStacks","prelude","decryptActionBoundArgs","encryptActionBoundArgs","isEdgeRuntime","textEncoder","textDecoder","filterStackFrame","filterStackFrameDEV","findSourceMapURL","findSourceMapURLDEV","decodeActionBoundArg","actionId","arg","originalPayload","ivValue","payload","decrypted","encodeActionBoundArg","randomBytes","exit","getRandomValues","encrypted","btoa","ReadStatus","cache","getCacheSignal","captureStackTrace","didCatchError","hangingInputAbortSignal","readStatus","startReadOnce","beginRead","endReadIfStarted","endRead","serialized","onError","prerenderResumeDataCache","getPrerenderResumeDataCache","renderResumeDataCache","getRenderResumeDataCache","cacheKey","cachedEncrypted","encryptedBoundArgs","encryptedPromise","decryptedBoundArgs","deserialized","createFromReadableStream","serverConsumerManifest","moduleLoading","moduleMap","RequestCookies","ResponseCookies","stringifyCookie","ReflectAdapter","target","prop","receiver","Reflect","deleteProperty","MutableRequestCookiesAdapter","ReadonlyRequestCookiesError","RequestCookiesAdapter","appendMutableCookies","areCookiesMutableInCurrentPhase","createCookiesWithMutableAccessCheck","getModifiedCookieValues","responseCookiesToRequestCookies","callable","seal","cookies","Proxy","SYMBOL_MODIFY_COOKIE_VALUES","modified","headers","mutableCookies","modifiedCookieValues","resCookies","returnedCookies","getAll","cookie","onUpdateCookies","responseCookies","Headers","modifiedValues","modifiedCookies","Set","updateResponseCookies","pathWasRevalidated","allCookies","serializedCookies","tempCookies","wrappedCookies","add","ensureCookiesAreStillMutable","phase","_callingExpression","requestCookies","createDedupedByCallsiteServerErrorLoggerDev","errorRef","current","logErrorOrWarn","__NEXT_CACHE_COMPONENTS","warn","flushCurrentErrorIfNew","getMessage","logDedupedError","callStackFrames","isRequestAPICallableInsideAfter","throwForSearchParamsAccessInUseCache","throwWithStaticGenerationBailoutErrorWithDynamicError","constructorOpt","invalidDynamicUsageError","afterTaskStore","afterTaskAsyncStorage","rootTaskSpawnPhase","callingExpression","underlyingCookies","createEmptyCookies","makeUntrackedCookies","makeHangingCookies","exportName","userspaceMutableCookies","makeUntrackedCookiesWithDevWarnings","CachedCookies","cachedPromise","cachedCookies","asyncApiPromises","instrumentCookiesPromiseWithDevWarnings","Runtime","proxiedPromise","warnForSyncAccess","createCookiesAccessError","defineProperties","iterator","replaceableWarningDescriptorForSymbolIterator","replaceableWarningDescriptor","clear","enumerable","defineProperty","configurable","prefix","HeadersAdapter","ReadonlyHeadersError","lowercased","original","keys","find","o","merge","from","append","existing","forEach","callbackfn","thisArg","call","underlyingHeaders","makeUntrackedHeaders","makeHangingHeaders","makeUntrackedHeadersWithDevWarnings","CachedHeaders","cachedHeaders","instrumentHeadersPromiseWithDevWarnings","createHeadersAccessError","getSetCookie","draftMode","createOrGetCachedDraftMode","draftModeProvider","getDraftModeProviderForCacheScope","NullDraftMode","cachedDraftMode","CachedDraftModes","isPrefetchRequest","createDraftModeWithDevWarnings","DraftMode","underlyingProvider","instance","provider","_provider","isEnabled","enable","trackDynamicDraftMode","disable","createDraftModeAccessError","ensureServerEntryExports","actions","action"],"mappings":"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","ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38]}